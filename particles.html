<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WebGPU Compute Particles</title>
<style>
  body {
    display: flex;
    margin: 0;
    padding: 0;
    background: #1a1a1a;
  }
  #control-panel {
    width: 200px;
    padding: 20px;
    background: #2a2a2a;
    color: white;
    font-family: Arial, sans-serif;
    font-size: 14px;
  }
  #control-panel h3 {
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 16px;
  }
  .control-group {
    margin-bottom: 20px;
  }
  .control-group label {
    display: block;
    margin-bottom: 5px;
    font-size: 12px;
    color: #ccc;
  }
  .control-group input[type="range"] {
    width: 100%;
    margin-bottom: 5px;
  }
  .control-group input[type="number"] {
    width: 100%;
    padding: 5px;
    background: #1a1a1a;
    color: white;
    border: 1px solid #444;
    border-radius: 3px;
    font-size: 12px;
  }
  .control-group .value-display {
    font-size: 11px;
    color: #888;
  }
  canvas { width: 1000px; height: 1000px; display: block; background: black; }
  #fps-counter {
    position: fixed;
    bottom: 10px;
    right: 10px;
    color: white;
    font-family: monospace;
    font-size: 12px;
    background: rgba(0, 0, 0, 0.5);
    padding: 4px 8px;
    border-radius: 4px;
  }
</style>
</head>
<body>
<div id="control-panel">
  <h3>Controls</h3>
  <div class="control-group">
    <label for="decay-factor">Decay Factor</label>
    <input type="range" id="decay-factor" min="0.9" max="1.0" step="0.001" value="0.99">
    <input type="number" id="decay-factor-value" min="0.9" max="1.0" step="0.001" value="0.99">
    <div class="value-display">Multiplies particle velocity each frame</div>
  </div>
</div>
<canvas id="gfx" width="1000" height="1000"></canvas>
<div id="fps-counter">FPS: --</div>
<script type="module">
console.log('Startup');
const adapter = await navigator.gpu.requestAdapter();
console.log('Got Adapter');
const device = await adapter.requestDevice();
console.log('Got Device');
const canvas = document.getElementById('gfx');
const context = canvas.getContext('webgpu');
console.log('Got Got WebGPU context');

const format = navigator.gpu.getPreferredCanvasFormat();
context.configure({ device, format });

const numParticles = 100000;



// JS-side data
const particleData = new Float32Array(numParticles * 4); // x, y, vx, vy
for (let i = 0; i < numParticles; i++) {
  particleData[i * 4 + 0] = (Math.random() * 2 - 1) * 0.9;  // x
  particleData[i * 4 + 1] = (Math.random() * 2 - 1) * 0.9;  // y
  particleData[i * 4 + 2] = (Math.random() * 2 - 1) * 0.1;  // vx
  particleData[i * 4 + 3] = (Math.random() * 2 - 1) * 0.1;  // vy
}

// GPU buffers
const particleBuffer = device.createBuffer({
  size: particleData.byteLength,
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
});
device.queue.writeBuffer(particleBuffer, 0, particleData);
console.log('Wrote particle buffer to GPU');

const cellIndexBuffer = device.createBuffer({
  size: numParticles * 4, // one u32 per particle
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
});

// Grid velocity buffer: 10x10 = 100 cells, each with vec2<f32> (8 bytes)
const numCells = 100;
const gridVelocityData = new Float32Array(numCells * 2); // Initialize to zero
const gridVelocityBuffer = device.createBuffer({
  size: gridVelocityData.byteLength,
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
});
device.queue.writeBuffer(gridVelocityBuffer, 0, gridVelocityData);
console.log('Created grid velocity buffer');


let decayFactor = 0.99;
const uniformData = new Float32Array([
  0.016, 0, 0, 0,     // dt + pad (16 bytes)
  0, 0, 0, 0,         // pad (16 bytes)
  0.0, -0.0, 0, 0,    // gravity (x,y) + pad (16 bytes)
  decayFactor, 0, 0, 0,  // decay factor + pad (16 bytes)
  0, 0, 0, 0,         // additional pad to reach 80 bytes minimum (16 bytes)
]);
const uniformBuffer = device.createBuffer({
  size: uniformData.byteLength,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
});
device.queue.writeBuffer(uniformBuffer, 0, uniformData);
console.log('Wrote uniform buffer to GPU');

// Control panel setup
const decayFactorSlider = document.getElementById('decay-factor');
const decayFactorInput = document.getElementById('decay-factor-value');

function updateDecayFactor(value) {
  decayFactor = parseFloat(value);
  decayFactorSlider.value = decayFactor;
  decayFactorInput.value = decayFactor;
  
  // Update uniform buffer
  uniformData[12] = decayFactor; // Index 12 is where decayFactor is stored
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
}

decayFactorSlider.addEventListener('input', (e) => {
  updateDecayFactor(e.target.value);
});

decayFactorInput.addEventListener('input', (e) => {
  const val = Math.max(0.9, Math.min(1.0, parseFloat(e.target.value) || 0.99));
  updateDecayFactor(val);
});

//
// === Compute Shader (WGSL) ===
//
const computeShaderCode = /* wgsl */`
struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
};

@group(0) @binding(0)
var<storage, read_write> particles: array<Particle>;

@group(0) @binding(1)
var<storage, read_write> cellIndices: array<u32>;

@group(0) @binding(3)
var<storage, read_write> gridVelocities: array<vec2<f32>>;

struct Params {
  dt: f32,
  _pad1: vec3<f32>,
  gravity: vec2<f32>,
  _pad2: vec2<f32>,
  decayFactor: f32,
  _pad3: vec3<f32>,
};
@group(0) @binding(2)
var<uniform> params: Params;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let i = id.x;
  if (i >= arrayLength(&particles)) { return; }

  var p = particles[i];

  // --- physics ---
  p.vel += params.gravity * params.dt;
  p.pos += p.vel * params.dt;

  // bounce
  if (abs(p.pos.x) > 1.0) { p.vel.x = -p.vel.x; }
  if (abs(p.pos.y) > 1.0) { p.vel.y = -p.vel.y; }

  // --- grid assignment ---
  let cellSize = 0.2;
  let gx = clamp(floor((p.pos.x + 1.0) / cellSize), 0.0, 9.0);
  let gy = clamp(floor((p.pos.y + 1.0) / cellSize), 0.0, 9.0);
  let cellIndex = u32(gy * 10.0 + gx);
  cellIndices[i] = cellIndex;

  // --- grid-particle interaction ---
  let gridVel = gridVelocities[cellIndex];
  let particleVelBefore = p.vel; // Store original particle velocity
  
  // Add 1/100 of the magnitude of grid velocity to particle velocity
  // (in the direction of the grid velocity)
  let gridVelMagnitude = length(gridVel);
  if (gridVelMagnitude > 0.0) {
    p.vel += normalize(gridVel) * (0.01 * gridVelMagnitude);
  }
  
  // Update grid velocity by adding 1/100th of particle velocity (before grid interaction)
  gridVelocities[cellIndex] = gridVel + particleVelBefore * 0.01;

  // Apply decay factor to particle velocity
  p.vel *= params.decayFactor;

  particles[i] = p;
}

`;

const computeModule = device.createShaderModule({ code: computeShaderCode });
const computePipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: computeModule, entryPoint: 'main' },
});
const computeBindGroup = device.createBindGroup({
  layout: computePipeline.getBindGroupLayout(0),
  entries: [
    { binding: 0, resource: { buffer: particleBuffer } },
    { binding: 1, resource: { buffer: cellIndexBuffer } },
    { binding: 2, resource: { buffer: uniformBuffer } },
    { binding: 3, resource: { buffer: gridVelocityBuffer } },
  ],
});

//
// === Render Shader (WGSL) ===
//
const renderShaderCode = /* wgsl */`
struct VSOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) color: vec4<f32>,
};

@group(0) @binding(0)
var<storage, read> particles: array<vec4<f32>>; // pos+vel packed

@group(0) @binding(1)
var<storage, read> cellIndices: array<u32>;

@vertex
fn vs_main(@builtin(vertex_index) vid: u32) -> VSOut {
  var out: VSOut;
  let p = particles[vid];
  out.pos = vec4<f32>(p.xy, 0.0, 1.0);

  let cell = cellIndices[vid];
  let gx = cell % 10u;
  let gy = cell / 10u;
  // Create distinct colors for each cell using both x and y
  let r = f32(gx) / 9.0;
  let g = f32(gy) / 9.0;
  let b = fract(f32(cell) / 7.0); // Add some variation
  out.color = vec4<f32>(r, g, b, 1.0);
  return out;
}

@fragment
fn fs_main(in: VSOut) -> @location(0) vec4<f32> {
  return in.color;
}

`;

const renderModule = device.createShaderModule({ code: renderShaderCode });
const renderPipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: {
    module: renderModule,
    entryPoint: 'vs_main',
  },
  fragment: {
    module: renderModule,
    entryPoint: 'fs_main',
    targets: [{ format }],
  },
  primitive: { topology: 'point-list' },
});
const renderBindGroup = device.createBindGroup({
  layout: renderPipeline.getBindGroupLayout(0),
  entries: [
    { binding: 0, resource: { buffer: particleBuffer } },
    { binding: 1, resource: { buffer: cellIndexBuffer } },
  ],
});

//
// === Frame loop ===
//
let lastTime = performance.now();
let frameCount = 0;
let fps = 0;
const fpsCounter = document.getElementById('fps-counter');

function frame() {
  const currentTime = performance.now();
  const deltaTime = currentTime - lastTime;
  frameCount++;
  
  // Update FPS every second
  if (deltaTime >= 1000) {
    fps = Math.round((frameCount * 1000) / deltaTime);
    fpsCounter.textContent = `FPS: ${fps}`;
    frameCount = 0;
    lastTime = currentTime;
  }
  
  const encoder = device.createCommandEncoder();

  // 1️⃣ Compute pass
  {
    const pass = encoder.beginComputePass();
    pass.setPipeline(computePipeline);
    pass.setBindGroup(0, computeBindGroup);
    pass.dispatchWorkgroups(Math.ceil(numParticles / 64));
    pass.end();
  }

  // 2️⃣ Render pass
  const textureView = context.getCurrentTexture().createView();
  const renderPass = encoder.beginRenderPass({
    colorAttachments: [{
      view: textureView,
      clearValue: { r: 0, g: 0, b: 0, a: 1 },
      loadOp: 'clear',
      storeOp: 'store',
    }],
  });
  renderPass.setPipeline(renderPipeline);
  renderPass.setBindGroup(0, renderBindGroup);
  renderPass.draw(numParticles);
  renderPass.end();

  device.queue.submit([encoder.finish()]);
  requestAnimationFrame(frame);
}

frame();
</script>
</body>
</html>