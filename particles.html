<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WebGPU Compute Particles</title>

<!-- experiments -->    
<!--  Add list of neighbors to particle structure -->
<!--  Flocking, with N nearest neighbors rather than grid  -->
<!--  Add coupling constant between grid and particles to control panel -->
<!--  Add firing state, firing behavior, weights for N neighbors to particle -->
<!--  Add letters i/o capability to particles  -->
<!--    -->
<style>
  body {
    display: flex;
    margin: 0;
    padding: 0;
    background: #1a1a1a;
  }
  #control-panel {
    width: 200px;
    padding: 20px;
    background: #2a2a2a;
    color: white;
    font-family: Arial, sans-serif;
    font-size: 14px;
  }
  #control-panel h3 {
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 16px;
  }
  .control-group {
    margin-bottom: 10px;
  }
  .control-group label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    color: #ccc;
  }
  .control-group input[type="range"] {
    width: 100%;
  }
  .control-group input[type="number"] {
    flex: 1;
    padding: 5px;
    background: #1a1a1a;
    color: white;
    border: 1px solid #444;
    border-radius: 3px;
    font-size: 12px;
  }
  canvas { 
    width: calc(100vw - 240px); 
    height: 100vh; 
    display: block; 
    background: black; 
  }
  #statistics {
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid #444;
  }
  #statistics h4 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 14px;
  }
  #fps-counter {
    color: white;
    font-family: monospace;
    font-size: 12px;
    margin-bottom: 8px;
  }
  #energy-counter {
    color: white;
    font-family: monospace;
    font-size: 12px;
    margin-bottom: 8px;
  }
  #timestamp-counter {
    color: white;
    font-family: monospace;
    font-size: 12px;
  }
</style>
</head>
<body>
<div id="control-panel">
  <h3>Controls</h3>
  <div class="control-group">
    <label for="num-particles">Number of Particles: <input type="number" id="num-particles" min="1000" max="10000000" step="1000"></label>
  </div>
  <div class="control-group">
    <label for="drag">Drag: <input type="number" id="drag" step="0.01" value="0.99"></label>
  </div>
  <div class="control-group">
    <label for="decay">Decay: <input type="number" id="decay" step="0.01" value="0.99"></label>
  </div>
  <div class="control-group">
    <label for="show-particles">
      <input type="checkbox" id="show-particles" checked>
      Show Particles
    </label>
  </div>
  <div class="control-group">
    <label for="show-grid">
      <input type="checkbox" id="show-grid">
      Show Grid
    </label>
  </div>
  <div class="control-group"> 
    <label for="do-flocking">
      <input type="checkbox" id="do-flocking" checked>
      Do Flocking
    </label>
  </div>
  <div class="control-group">
    <label for="color-mode">Color Mode:
      <select id="color-mode">
        <option value="0">Monochrome</option>
        <option value="1" selected>Velocity</option>
        <option value="2">Cell</option>
      </select>
    </label>
  </div>
  <div class="control-group">
    <label for="show-edges">
      <input type="checkbox" id="show-edges">
      Show Edges
    </label>
  </div>
  <div class="control-group">
    <label for="couple-to-grid">
      <input type="checkbox" id="couple-to-grid" checked>
      Couple to Grid
    </label>
  </div>
  <div class="control-group">
    <label for="torus">
      <input type="checkbox" id="torus">
      Torus
    </label>
  </div>
  <div class="control-group">
    <label for="cohesion">Cohesion: <input type="number" id="cohesion" step="0.001" value="0.03"></label>
  </div>
  <div class="control-group">
    <label for="separation-strength">Separation Strength: <input type="number" id="separation-strength" step="0.001" value="0.05"></label>
  </div>
  <div class="control-group">
    <label for="separation-distance">Separation Distance: <input type="number" id="separation-distance" step="0.001" value="0.02"></label>
  </div>
  <div class="control-group">
    <label for="alignment">Alignment: <input type="number" id="alignment" step="0.001" value="0.009"></label>
  </div>
  <div class="control-group">
    <label for="drag-radius">Drag Radius: <input type="number" id="drag-radius" step="0.01" value="0.05" min="0.01" max="1.0"></label>
  </div>
  <div class="control-group">
    <label for="drag-strength">Drag Strength: <input type="number" id="drag-strength" step="0.01" value="0.03" min="0.001" max="50.0"></label>
  </div>
  <div class="control-group">
    <button id="start-stop-btn" style="padding: 8px 16px; font-size: 14px; cursor: pointer;">Stop</button>
  </div>
  <div id="statistics">
    <h4>Statistics</h4>
    <div id="fps-counter">FPS: --</div>
    <div id="energy-counter">Energy: --</div>
    <div id="timestamp-counter">GPU Timing: --</div>
  </div>
</div>
<canvas id="gfx" width="1000" height="1000"></canvas>
<script type="module">
console.log('Startup');
const adapter = await navigator.gpu.requestAdapter();
console.log('Got Adapter');

// Check for timestamp query support
const requiredFeatures = [];
if (adapter.features.has('timestamp-query')) {
  requiredFeatures.push('timestamp-query');
  console.log('Timestamp queries supported');
} else {
  console.warn('Timestamp queries not supported - GPU timing will not be available');
}

const device = await adapter.requestDevice({ requiredFeatures });
console.log('Got Device');
const canvas = document.getElementById('gfx');
const context = canvas.getContext('webgpu');
console.log('Got Got WebGPU context');

const format = navigator.gpu.getPreferredCanvasFormat();

// Function to resize canvas to fill available space
function resizeCanvas() {
  const controlPanelWidth = 240; // 200px width + 40px padding
  const newWidth = window.innerWidth - controlPanelWidth;
  const newHeight = window.innerHeight;
  
  canvas.width = newWidth;
  canvas.height = newHeight;
  
  // Reconfigure WebGPU context with new size
  context.configure({ 
    device, 
    format,
    width: newWidth,
    height: newHeight
  });
  
  console.log(`Canvas resized to ${newWidth}x${newHeight}`);
}

// Initial resize
resizeCanvas();

// Resize on window resize
window.addEventListener('resize', () => {
  resizeCanvas();
});

let numParticles = 100000;
const MAX_NEIGHBORS = 16; // Maximum number of neighbors per particle for flocking
let particleBuffer, cellIndexBuffer, computeBindGroup, renderBindGroup;
let neighborIndicesBuffer, neighborCountBuffer; // Neighbor list buffers
let renderParamsBuffer; // Uniform buffer for render parameters (monochrome flag)
let edgeBindGroup; // Bind group for edge rendering
let colorParamsBuffer; // Uniform buffer for color mode
let cellParticleListsBuffer; // Maps cells to particle indices for fast neighbor lookup
let frameId = null;

// Timestamp query infrastructure for GPU timing
let timestampQuerySet = null;
let timestampBuffer = null;
let timestampReadbackPending = false;
let lastTimestampReadTime = 0;
const TIMESTAMP_READ_INTERVAL = 1000; // Read timestamps every second
const timestampCounter = document.getElementById('timestamp-counter');

// Initialize timestamp query set if supported
if (device.features.has('timestamp-query')) {
  // Create query set with 6 queries: 
  // 0-1: particle compute (start, end)
  // 2-3: findNeighbors (start, end)
  // 4-5: flocking (start, end)
  timestampQuerySet = device.createQuerySet({
    type: 'timestamp',
    count: 6,
  });
  
  // Create buffer to read back timestamps (6 u64 values = 48 bytes)
  timestampBuffer = device.createBuffer({
    size: 48,
    usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
  });
  
  console.log('Created timestamp query infrastructure');
}

// Helper function to create a compute pass with timestamp queries
// queryIndexOffset: 0 for particle compute, 2 for findNeighbors
function createTimedComputePass(encoder, queryIndexOffset = 0) {
  if (!timestampQuerySet) {
    // Timestamp queries not supported, return normal pass
    return encoder.beginComputePass();
  }
  
  // Create compute pass with timestamp writes
  return encoder.beginComputePass({
    timestampWrites: {
      querySet: timestampQuerySet,
      beginningOfPassWriteIndex: queryIndexOffset,
      endOfPassWriteIndex: queryIndexOffset + 1,
    },
  });
}

// Function to resolve and read back timestamps
function resolveTimestamps(encoder, currentTime) {
  if (!timestampQuerySet || !timestampBuffer || !timestampStagingBuffer) {
    return false;
  }
  
  const shouldReadTimestamp = !timestampReadbackPending && 
                               (currentTime - lastTimestampReadTime >= TIMESTAMP_READ_INTERVAL);
  
  if (shouldReadTimestamp) {
    // Resolve all queries (6 queries) to buffer
    encoder.resolveQuerySet(timestampQuerySet, 0, 6, timestampBuffer, 0);
    // Copy from timestamp buffer to staging buffer for readback
    encoder.copyBufferToBuffer(timestampBuffer, 0, timestampStagingBuffer, 0, 48);
    timestampReadbackPending = true;
    lastTimestampReadTime = currentTime;
    return true;
  }
  return false;
}

// Staging buffer for timestamp readback
let timestampStagingBuffer = null;
if (timestampBuffer) {
  timestampStagingBuffer = device.createBuffer({
    size: 48, // 6 u64 values
    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
  });
}

function initializeParticles() {
  // JS-side data: x, y, vx, vy, r, g, b, _pad (8 floats per particle, 32 bytes)
  // vec3<f32> is aligned to 16 bytes in WGSL, so we need padding
  const particleData = new Float32Array(numParticles * 8);
  for (let i = 0; i < numParticles; i++) {
    particleData[i * 8 + 0] = (Math.random() * 2 - 1) * 0.9;  // x
    particleData[i * 8 + 1] = (Math.random() * 2 - 1) * 0.9;  // y
    particleData[i * 8 + 2] = (Math.random() * 2 - 1) * 0.1;  // vx
    particleData[i * 8 + 3] = (Math.random() * 2 - 1) * 0.1;  // vy
    particleData[i * 8 + 4] = 1.0;  // r (will be set by color shader)
    particleData[i * 8 + 5] = 1.0;  // g
    particleData[i * 8 + 6] = 1.0;  // b
    particleData[i * 8 + 7] = 0.0;  // _pad (padding)
  }

  // GPU buffers
  if (particleBuffer) {
    particleBuffer.destroy();
  }
  particleBuffer = device.createBuffer({
    size: particleData.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(particleBuffer, 0, particleData);
  console.log('Wrote particle buffer to GPU');

  if (cellIndexBuffer) {
    cellIndexBuffer.destroy();
  }
  cellIndexBuffer = device.createBuffer({
    size: numParticles * 4, // one u32 per particle
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });
  
  // Neighbor indices buffer: flattened array where each particle has MAX_NEIGHBORS consecutive slots
  // Layout: [particle0_neighbor0, particle0_neighbor1, ..., particle0_neighborN-1, particle1_neighbor0, ...]
  if (neighborIndicesBuffer) {
    neighborIndicesBuffer.destroy();
  }
  neighborIndicesBuffer = device.createBuffer({
    size: numParticles * MAX_NEIGHBORS * 4, // MAX_NEIGHBORS u32s per particle
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });
  // Initialize to invalid indices (numParticles, which is out of bounds)
  const neighborInitData = new Uint32Array(numParticles * MAX_NEIGHBORS);
  neighborInitData.fill(numParticles); // Use numParticles as invalid marker (out of bounds)
  device.queue.writeBuffer(neighborIndicesBuffer, 0, neighborInitData);
  console.log('Created neighbor indices buffer');
  
  // Neighbor count buffer: one u32 per particle storing how many valid neighbors it has
  if (neighborCountBuffer) {
    neighborCountBuffer.destroy();
  }
  neighborCountBuffer = device.createBuffer({
    size: numParticles * 4, // one u32 per particle
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });
  // Initialize to zero
  device.queue.writeBuffer(neighborCountBuffer, 0, new Uint32Array(numParticles));
  console.log('Created neighbor count buffer');
  
  // Cell-to-particle mapping buffer: for each cell, store indices of particles in that cell
  // Note: MAX_PARTICLES_PER_CELL is fixed at shader compile time (512), so we use that value
  // If particles exceed this per cell, they will be dropped (but this should be rare with 512)
  const MAX_PARTICLES_PER_CELL = window.MAX_PARTICLES_PER_CELL;
  if (cellParticleListsBuffer) {
    cellParticleListsBuffer.destroy();
  }
  cellParticleListsBuffer = device.createBuffer({
    size: numCells * MAX_PARTICLES_PER_CELL * 4, // u32 per particle index
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });
  // Initialize to invalid indices
  const cellListInitData = new Uint32Array(numCells * MAX_PARTICLES_PER_CELL);
  cellListInitData.fill(0xFFFFFFFF); // Invalid marker (JavaScript, not WGSL)
  device.queue.writeBuffer(cellParticleListsBuffer, 0, cellListInitData);
  console.log(`Created cell-to-particle mapping buffer (${MAX_PARTICLES_PER_CELL} particles per cell max)`);
  
  // Store MAX_PARTICLES_PER_CELL globally for shader compilation
  window.MAX_PARTICLES_PER_CELL = MAX_PARTICLES_PER_CELL;
  
  // Recreate bind groups with new buffers
  computeBindGroup = device.createBindGroup({
    layout: computePipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: particleBuffer } },
      { binding: 1, resource: { buffer: cellIndexBuffer } },
      { binding: 2, resource: { buffer: uniformBuffer } },
      { binding: 3, resource: { buffer: gridVelocityBuffer } },
      { binding: 4, resource: { buffer: energySumBuffer } },
      { binding: 5, resource: { buffer: particleCountBuffer } },
    ],
  });
  
  // Create render params uniform buffer (just for monochrome flag)
  const renderParamsData = new Float32Array(1);
  renderParamsData[0] = monochrome ? 1.0 : 0.0;
  renderParamsBuffer = device.createBuffer({
    size: renderParamsData.byteLength,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(renderParamsBuffer, 0, renderParamsData);
  
  renderBindGroup = device.createBindGroup({
    layout: renderPipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: particleBuffer } },
    ],
  });
  
  // Create edge rendering bind group
  edgeBindGroup = device.createBindGroup({
    layout: edgePipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: particleBuffer } },
      { binding: 1, resource: { buffer: neighborIndicesBuffer } },
      { binding: 2, resource: { buffer: neighborCountBuffer } },
      { binding: 3, resource: { buffer: uniformBuffer } },
    ],
  });
  
  // Create build cell mapping bind group
  buildCellMappingBindGroup = device.createBindGroup({
    layout: buildCellMappingPipeline.getBindGroupLayout(0),
    entries: [
      { binding: 1, resource: { buffer: cellIndexBuffer } },
      { binding: 4, resource: { buffer: cellParticleListsBuffer } },
      { binding: 5, resource: { buffer: particleCountBuffer } },
    ],
  });
  
  // Create find neighbors bind group
  findNeighborsBindGroup = device.createBindGroup({
    layout: findNeighborsPipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: particleBuffer } },
      { binding: 1, resource: { buffer: cellIndexBuffer } },
      { binding: 2, resource: { buffer: neighborIndicesBuffer } },
      { binding: 3, resource: { buffer: neighborCountBuffer } },
      { binding: 4, resource: { buffer: cellParticleListsBuffer } },
      { binding: 5, resource: { buffer: particleCountBuffer } },
      { binding: 6, resource: { buffer: uniformBuffer } },
    ],
  });
  
  // Create flocking bind group
  flockingBindGroup = device.createBindGroup({
    layout: flockingPipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: particleBuffer } },
      { binding: 1, resource: { buffer: neighborIndicesBuffer } },
      { binding: 2, resource: { buffer: neighborCountBuffer } },
      { binding: 3, resource: { buffer: uniformBuffer } },
    ],
  });
  
  // Create color params uniform buffer
  const colorParamsData = new Float32Array(1);
  colorParamsData[0] = colorMode;
  if (colorParamsBuffer) {
    colorParamsBuffer.destroy();
  }
  colorParamsBuffer = device.createBuffer({
    size: colorParamsData.byteLength,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(colorParamsBuffer, 0, colorParamsData);
  
  // Create color bind group
  colorBindGroup = device.createBindGroup({
    layout: colorPipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: particleBuffer } },
      { binding: 1, resource: { buffer: cellIndexBuffer } },
      { binding: 2, resource: { buffer: colorParamsBuffer } },
    ],
  });
  
  // Create mouse interaction bind group
  mouseInteractionBindGroup = device.createBindGroup({
    layout: mouseInteractionPipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: particleBuffer } },
      { binding: 1, resource: { buffer: mouseParamsBuffer } },
    ],
  });
}

// Grid configuration: cells per direction
const cellsPerDirection = 50;
const numCells = cellsPerDirection * cellsPerDirection;

// Calculate MAX_PARTICLES_PER_CELL at top level for shader compilation
// Use a large fixed value to handle all reasonable particle counts (up to 10M particles)
// This is compiled into shaders, so it can't change at runtime
// For 10M particles / 2500 cells = 4000 average, with clustering we need much more
// 512 should handle most cases (can be increased to 1024 or 2048 if needed)
window.MAX_PARTICLES_PER_CELL = 512; // Fixed value that should handle most cases
const gridVelocityData = new Float32Array(numCells * 2); // Initialize to zero
const gridVelocityBuffer = device.createBuffer({
  size: gridVelocityData.byteLength,
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
});
device.queue.writeBuffer(gridVelocityBuffer, 0, gridVelocityData);
console.log('Created grid velocity buffer');

// Particle count buffer: one u32 per cell
const particleCountBuffer = device.createBuffer({
  size: numCells * 4, // one u32 (4 bytes) per cell
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
});
// Initialize to zero
device.queue.writeBuffer(particleCountBuffer, 0, new Uint32Array(numCells));
console.log('Created particle count buffer');


let drag = 1.0;
let decay = 1.0;
let dt = 0.016;
let cohesion = 0.5;
let separationStrength = 0.05;
let separationDistance = 0.01;
let alignment = 0.012;
let monochrome = false;
let coupleToGrid = true; // Default to enabled
let torus = false; // Default to disabled (bouncing)
let colorMode = 1; // 0 = monochrome, 1 = velocity, 2 = cell

// Mouse interaction state
let mouseDragRadius = 0.05;
let mouseDragStrength = 0.03;
let isMouseDragging = false;
let mousePos = { x: 0, y: 0 }; // In particle coordinate space (-1 to 1)

const uniformData = new Float32Array(32); // Increased to accommodate new parameters
uniformData[0] = dt;
uniformData[1] = drag;
uniformData[2] = decay;
uniformData[3] = cohesion;
uniformData[4] = separationStrength;
uniformData[5] = separationDistance;
uniformData[6] = alignment;
uniformData[7] = coupleToGrid ? 1.0 : 0.0; // Couple to grid flag (f32: 1.0 = true, 0.0 = false)
uniformData[8] = torus ? 1.0 : 0.0; // Torus flag (f32: 1.0 = true, 0.0 = false)

const uniformBuffer = device.createBuffer({
  size: uniformData.byteLength,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
});
device.queue.writeBuffer(uniformBuffer, 0, uniformData);
console.log('Wrote uniform buffer to GPU');

// Mouse interaction uniform buffer
const mouseParamsData = new Float32Array(6); // mousePos (2), dragRadius, dragStrength, isActive, torus
mouseParamsData[0] = 0.0; // mousePos.x
mouseParamsData[1] = 0.0; // mousePos.y
mouseParamsData[2] = mouseDragRadius;
mouseParamsData[3] = mouseDragStrength;
mouseParamsData[4] = 0.0; // isActive
mouseParamsData[5] = torus ? 1.0 : 0.0; // torus

const mouseParamsBuffer = device.createBuffer({
  size: mouseParamsData.byteLength,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
});
device.queue.writeBuffer(mouseParamsBuffer, 0, mouseParamsData);
console.log('Created mouse params buffer');

// Mouse interaction bind group will be created after particleBuffer is initialized
let mouseInteractionBindGroup;

// Energy sum buffer (atomic u32)
const energySumBuffer = device.createBuffer({
  size: 4, // single u32
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
});

// Staging buffer to read back energy
const energyStagingBuffer = device.createBuffer({
  size: 4,
  usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
});

// Initialize energy buffer to zero
device.queue.writeBuffer(energySumBuffer, 0, new Uint32Array([0]));
console.log('Created energy sum buffer');

//
// === Compute Shader (WGSL) ===
//
const computeShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u; 
const CELL_SIZE = 2.0 / f32(CELLS_PER_DIRECTION);
const MAX_CELL_INDEX = ${cellsPerDirection - 1}u;

struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
  color: vec3<f32>,
  _pad: f32, // Padding to align struct to 32 bytes (8 floats)
};

@group(0) @binding(0)
var<storage, read_write> particles: array<Particle>;

@group(0) @binding(1)
var<storage, read_write> cellIndices: array<u32>;

@group(0) @binding(3)
var<storage, read_write> gridVelocities: array<vec2<f32>>;

@group(0) @binding(4)
var<storage, read_write> energySum: atomic<u32>;

@group(0) @binding(5)
var<storage, read_write> particleCounts: array<atomic<u32>>;

struct Params {
  dt: f32,
  drag: f32,
  decay: f32,
  cohesion: f32,
  separationStrength: f32,
  separationDistance: f32,
  alignment: f32,
  coupleToGrid: f32, // 1.0 = true, 0.0 = false
  torus: f32, // 1.0 = true, 0.0 = false
};

@group(0) @binding(2)
var<uniform> params: Params;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let i = id.x;
  if (i >= arrayLength(&particles)) { return; }

  var p = particles[i];

  // --- physics ---
  p.pos += p.vel * params.dt;

  // boundary handling: bounce or wrap (torus)
  if (params.torus > 0.5) {
    // Torus mode: wrap around edges (coordinate range is -1.0 to 1.0, width is 2.0)
    // Wrap x coordinate: p.pos.x = ((p.pos.x + 1.0) mod 2.0) - 1.0
    p.pos.x = fract((p.pos.x + 1.0) / 2.0) * 2.0 - 1.0;
    // Wrap y coordinate
    p.pos.y = fract((p.pos.y + 1.0) / 2.0) * 2.0 - 1.0;
  } else {
    // Bounce mode: reflect velocity
    if (abs(p.pos.x) > 1.0) { p.vel.x = -p.vel.x; }
    if (abs(p.pos.y) > 1.0) { p.vel.y = -p.vel.y; }
  }

  // --- grid assignment ---
  let gx = clamp(floor((p.pos.x + 1.0) / CELL_SIZE), 0.0, f32(MAX_CELL_INDEX));
  let gy = clamp(floor((p.pos.y + 1.0) / CELL_SIZE), 0.0, f32(MAX_CELL_INDEX));
  let cellIndex = u32(gy * f32(CELLS_PER_DIRECTION) + gx);
  cellIndices[i] = cellIndex;

  // Count particle in this cell (atomic increment)
  atomicAdd(&particleCounts[cellIndex], 1u);

  // --- grid-particle interaction ---
  if (params.coupleToGrid > 0.5) {
    let gridVel = gridVelocities[cellIndex];
    let particleVelBefore = p.vel; // Store original particle velocity
    
    // grid-particle coupling constants 
    const GRID_TO_PARTICLE = 0.1;    // typical 0.1
    const PARTICLE_TO_GRID = 0.001;    // typical 0.001

    // Add grid velocity to particle velocity
    let gridVelMagnitude = length(gridVel);
    if (gridVelMagnitude > 0.0) {
      p.vel += normalize(gridVel) * (PARTICLE_TO_GRID * gridVelMagnitude);
    }
    
    // Accumulate particle velocity contribution to grid (will be normalized by count later)
    gridVelocities[cellIndex] = gridVel + particleVelBefore * GRID_TO_PARTICLE;
  }

  // Apply decay proportional to square of velocity
  let velSquared = dot(p.vel, p.vel);
  
  p.vel *= (1.0 - velSquared * params.drag); 
  p.vel *= params.decay;
  
  // Accumulate energy (velocity^2) atomically
  // Convert velSquared (0.0-1.0) to u32 in range 1-100
  let energyValue = u32(velSquared * 10000.0);  
  atomicAdd(&energySum, energyValue);
  
  particles[i] = p;
}

`;

const computeModule = device.createShaderModule({ code: computeShaderCode });
const computePipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: computeModule, entryPoint: 'main' },
});

//
// === Grid Decay Compute Shader (WGSL) ===
//
const gridDecayShaderCode = /* wgsl */`
@group(0) @binding(3)
var<storage, read_write> gridVelocities: array<vec2<f32>>;

struct Params {
  dt: f32,
  drag: f32,
  decay: f32,
};
@group(0) @binding(2)
var<uniform> params: Params;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let i = id.x;
  if (i >= arrayLength(&gridVelocities)) { return; }
  
  // Apply decay factor to grid velocity
  gridVelocities[i] *= params.decay;
}

`;

const gridDecayModule = device.createShaderModule({ code: gridDecayShaderCode });
const gridDecayPipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: gridDecayModule, entryPoint: 'main' },
});
const gridDecayBindGroup = device.createBindGroup({
  layout: gridDecayPipeline.getBindGroupLayout(0),
  entries: [
    { binding: 2, resource: { buffer: uniformBuffer } },
    { binding: 3, resource: { buffer: gridVelocityBuffer } },
  ],
});

//
// === Velocity Normalization Compute Shader (WGSL) ===
//
const normalizeVelocityShaderCode = /* wgsl */`
@group(0) @binding(0)
var<storage, read_write> gridVelocities: array<vec2<f32>>;

@group(0) @binding(1)
var<storage, read_write> particleCounts: array<atomic<u32>>;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let i = id.x;
  if (i >= arrayLength(&gridVelocities)) { return; }
  
  // Get particle count for this cell
  let count = f32(atomicLoad(&particleCounts[i]));
  
  // Normalize velocity by particle count (avoid division by zero)
  if (count > 0.0) {
    gridVelocities[i] = gridVelocities[i] / count;
  } else {
    gridVelocities[i] = vec2<f32>(0.0, 0.0);
  }
}
`;

const normalizeVelocityModule = device.createShaderModule({ code: normalizeVelocityShaderCode });
const normalizeVelocityPipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: normalizeVelocityModule, entryPoint: 'main' },
});

const normalizeVelocityBindGroup = device.createBindGroup({
  layout: normalizeVelocityPipeline.getBindGroupLayout(0),
  entries: [
    { binding: 0, resource: { buffer: gridVelocityBuffer } },
    { binding: 1, resource: { buffer: particleCountBuffer } },
  ],
});

//
// === Build Cell-to-Particle Mapping Compute Shader (WGSL) ===
// Builds a list of particle indices for each cell for fast neighbor lookup
//
const buildCellMappingShaderCode = /* wgsl */`
const MAX_PARTICLES_PER_CELL = ${window.MAX_PARTICLES_PER_CELL}u;

@group(0) @binding(1)
var<storage, read> cellIndices: array<u32>;

@group(0) @binding(4)
var<storage, read_write> cellParticleLists: array<u32>; // Flattened: numCells * MAX_PARTICLES_PER_CELL

@group(0) @binding(5)
var<storage, read_write> particleCounts: array<atomic<u32>>;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let particleIdx = id.x;
  if (particleIdx >= arrayLength(&cellIndices)) { return; }
  
  let cellIdx = cellIndices[particleIdx];
  
  // Get the current count for this cell (atomically)
  let slot = atomicAdd(&particleCounts[cellIdx], 1u);
  
  // Check if we have room in this cell's list
  if (slot < MAX_PARTICLES_PER_CELL) {
    let listBase = cellIdx * MAX_PARTICLES_PER_CELL;
    cellParticleLists[listBase + slot] = particleIdx;
  }
  // If slot >= MAX_PARTICLES_PER_CELL, we've exceeded capacity (shouldn't happen with good estimate)
}
`;

const buildCellMappingModule = device.createShaderModule({ code: buildCellMappingShaderCode });
const buildCellMappingPipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: buildCellMappingModule, entryPoint: 'main' },
});

let buildCellMappingBindGroup; // Will be created in initializeParticles()

//
// === Find Neighbors Compute Shader (WGSL) ===
// Finds the N nearest neighbors for each particle using the grid for spatial acceleration
//
const findNeighborsShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;
const MAX_NEIGHBORS = ${MAX_NEIGHBORS}u;
const MAX_PARTICLES_PER_CELL = ${window.MAX_PARTICLES_PER_CELL}u;

struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
  color: vec3<f32>,
  _pad: f32, // Padding to align struct to 32 bytes (8 floats)
};

@group(0) @binding(0)
var<storage, read> particles: array<Particle>;

@group(0) @binding(1)
var<storage, read> cellIndices: array<u32>;

@group(0) @binding(2)
var<storage, read_write> neighborIndices: array<u32>;

@group(0) @binding(3)
var<storage, read_write> neighborCounts: array<u32>;

@group(0) @binding(4)
var<storage, read> cellParticleLists: array<u32>; // Flattened: numCells * MAX_PARTICLES_PER_CELL

@group(0) @binding(5)
var<storage, read_write> particleCounts: array<atomic<u32>>; // Count of particles per cell (atomic)

struct Params {
  dt: f32,
  drag: f32,
  decay: f32,
  cohesion: f32,
  separationStrength: f32,
  separationDistance: f32,
  alignment: f32,
  coupleToGrid: f32,
  torus: f32, // 1.0 = true, 0.0 = false
};

@group(0) @binding(6)
var<uniform> params: Params;

// Helper function to calculate toroidal distance squared
fn toroidalDistSq(pos1: vec2<f32>, pos2: vec2<f32>) -> f32 {
  var dx = pos2.x - pos1.x;
  var dy = pos2.y - pos1.y;
  
  // Wrap distance components for torus (coordinate range is -1.0 to 1.0, width is 2.0)
  if (abs(dx) > 1.0) {
    dx = dx - sign(dx) * 2.0;
  }
  if (abs(dy) > 1.0) {
    dy = dy - sign(dy) * 2.0;
  }
  
  return dx * dx + dy * dy;
}

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let particleIdx = id.x;
  if (particleIdx >= arrayLength(&particles)) { return; }
  
  let p = particles[particleIdx];
  let myCell = cellIndices[particleIdx];
  
  // Calculate grid coordinates for this particle's cell
  let myGx = myCell % CELLS_PER_DIRECTION;
  let myGy = myCell / CELLS_PER_DIRECTION;
  
  // Array to store candidate neighbors with their distances
  var nearestIndices: array<u32, MAX_NEIGHBORS>;
  var nearestDistances: array<f32, MAX_NEIGHBORS>;
  var numFound: u32 = 0u;
  
  // Initialize distances to a large value
  for (var i = 0u; i < MAX_NEIGHBORS; i++) {
    nearestDistances[i] = 1000000.0; // Large initial distance
    nearestIndices[i] = 0xFFFFFFFFu; // Invalid index marker
  }
  
  // Check particles in the same cell and 8 adjacent cells (3x3 grid)
  for (var dy = 0u; dy < 3u; dy++) {
    for (var dx = 0u; dx < 3u; dx++) {
      // Convert 0-2 range to -1 to +1 range
      var offsetX = i32(dx) - 1;
      var offsetY = i32(dy) - 1;
      
      var checkGx = i32(myGx) + offsetX;
      var checkGy = i32(myGy) + offsetY;
      
      // Skip if out of bounds
      if (checkGx < 0 || checkGx >= i32(CELLS_PER_DIRECTION)) { continue; }
      if (checkGy < 0 || checkGy >= i32(CELLS_PER_DIRECTION)) { continue; }
      
      let checkCell = u32(checkGy) * CELLS_PER_DIRECTION + u32(checkGx);
      
      // Get the list of particles in this cell from the pre-built mapping
      let cellParticleCountRaw = atomicLoad(&particleCounts[checkCell]);
      // Clamp to MAX_PARTICLES_PER_CELL because particles beyond capacity are dropped
      let cellParticleCount = min(cellParticleCountRaw, MAX_PARTICLES_PER_CELL);
      let listBase = checkCell * MAX_PARTICLES_PER_CELL;
      
      // Iterate only through particles in this cell (much faster!)
      for (var slot = 0u; slot < cellParticleCount; slot++) {
        let candidateIdx = cellParticleLists[listBase + slot];
        if (candidateIdx == particleIdx) { continue; } // Skip self
        if (candidateIdx >= arrayLength(&particles)) { continue; } // Skip invalid
        
        let candidate = particles[candidateIdx];
        // Use toroidal distance if torus mode is enabled
        let distSq = select(
          dot(candidate.pos - p.pos, candidate.pos - p.pos),
          toroidalDistSq(p.pos, candidate.pos),
          params.torus > 0.5
        );
        
        // Insert this candidate if it's closer than our current farthest neighbor
        // Find the worst (farthest) neighbor in our list
        var worstIdx = 0u;
        var worstDist = nearestDistances[0u];
        for (var k = 1u; k < MAX_NEIGHBORS; k++) {
          if (nearestDistances[k] > worstDist) {
            worstDist = nearestDistances[k];
            worstIdx = k;
          }
        }
        
        // If this candidate is closer than our worst, replace it
        if (distSq < worstDist) {
          nearestDistances[worstIdx] = distSq;
          nearestIndices[worstIdx] = candidateIdx;
          if (numFound < MAX_NEIGHBORS) {
            numFound++;
          }
        }
      }
    }
  }
  
  // Write results to buffers
  let baseIndex = particleIdx * MAX_NEIGHBORS;
  for (var i = 0u; i < MAX_NEIGHBORS; i++) {
    if (i < numFound) {
      neighborIndices[baseIndex + i] = nearestIndices[i];
    } else {
      neighborIndices[baseIndex + i] = 0xFFFFFFFFu; // Invalid marker
    }
  }
  neighborCounts[particleIdx] = numFound;
}
`;

const findNeighborsModule = device.createShaderModule({ code: findNeighborsShaderCode });
const findNeighborsPipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: findNeighborsModule, entryPoint: 'main' },
});

let findNeighborsBindGroup; // Will be created in initializeParticles()

//
// === Flocking Compute Shader (WGSL) ===
// Applies cohesion, separation, and alignment forces based on neighbors
//
const flockingShaderCode = /* wgsl */`
const MAX_NEIGHBORS = ${MAX_NEIGHBORS}u;

struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
  color: vec3<f32>,
  _pad: f32, // Padding to align struct to 32 bytes (8 floats)
};

@group(0) @binding(0)
var<storage, read_write> particles: array<Particle>;

@group(0) @binding(1)
var<storage, read> neighborIndices: array<u32>; // Flattened: numParticles * MAX_NEIGHBORS

@group(0) @binding(2)
var<storage, read> neighborCounts: array<u32>; // One per particle

struct Params {
  dt: f32,
  drag: f32,
  decay: f32,
  cohesion: f32,
  separationStrength: f32,
  separationDistance: f32,
  alignment: f32,
  coupleToGrid: f32,
  torus: f32, // 1.0 = true, 0.0 = false
};

@group(0) @binding(3)
var<uniform> params: Params;

// Helper function to calculate toroidal difference vector
fn toroidalDiff(pos1: vec2<f32>, pos2: vec2<f32>) -> vec2<f32> {
  var dx = pos2.x - pos1.x;
  var dy = pos2.y - pos1.y;
  
  // Wrap difference components for torus (coordinate range is -1.0 to 1.0, width is 2.0)
  if (abs(dx) > 1.0) {
    dx = dx - sign(dx) * 2.0;
  }
  if (abs(dy) > 1.0) {
    dy = dy - sign(dy) * 2.0;
  }
  
  return vec2<f32>(dx, dy);
}

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let particleIdx = id.x;
  if (particleIdx >= arrayLength(&particles)) { return; }
  
  var p = particles[particleIdx];
  let numNeighbors = neighborCounts[particleIdx];
  
  if (numNeighbors == 0u) { return; } // No neighbors, no flocking
  
  let baseIndex = particleIdx * MAX_NEIGHBORS;
  
  // Accumulators for flocking forces
  var cohesionForce = vec2<f32>(0.0, 0.0); // Move toward average position
  var separationForce = vec2<f32>(0.0, 0.0); // Move away from close neighbors
  var alignmentForce = vec2<f32>(0.0, 0.0); // Match average velocity
  var validNeighbors = 0u;
  
  // Iterate through neighbors
  for (var n = 0u; n < numNeighbors && n < MAX_NEIGHBORS; n++) {
    let neighborIdx = neighborIndices[baseIndex + n];
    if (neighborIdx >= arrayLength(&particles)) { continue; } // Skip invalid
    
    let neighbor = particles[neighborIdx];
    // Use toroidal difference if torus mode is enabled
    let diff = select(
      neighbor.pos - p.pos,
      toroidalDiff(p.pos, neighbor.pos),
      params.torus > 0.5
    );
    let distSq = dot(diff, diff);
    let dist = sqrt(distSq);
    
    if (dist > 0.001) { // Avoid division by zero
      let diffNorm = diff / dist;
      
      // Cohesion: move toward neighbor's position
      cohesionForce += diff * params.cohesion;
      
      // Separation: move away from neighbors that are too close
      if (dist < params.separationDistance) {
        separationForce -= diffNorm * params.separationStrength;  // / (dist + 0.001);
      }
      
      // Alignment: match neighbor's velocity
      alignmentForce += neighbor.vel * params.alignment;
      
      validNeighbors++;
    }
  }
  
  if (validNeighbors > 0u) {
    // Normalize forces by number of neighbors
    let invCount = 1.0 / f32(validNeighbors);
    cohesionForce *= invCount;
    separationForce *= invCount;
    alignmentForce *= invCount;
    
    // Apply forces to velocity
    p.vel += cohesionForce + separationForce + alignmentForce;
  }
  
  particles[particleIdx] = p;
}
`;

const flockingModule = device.createShaderModule({ code: flockingShaderCode });
const flockingPipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: flockingModule, entryPoint: 'main' },
});

let flockingBindGroup; // Will be created in initializeParticles()

//
// === Color Compute Shader (WGSL) ===
// Sets particle colors based on mode: monochrome, velocity, or cell
//
const colorShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;

struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
  color: vec3<f32>,
  _pad: f32, // Padding to align struct to 32 bytes (8 floats)
};

@group(0) @binding(0)
var<storage, read_write> particles: array<Particle>;

@group(0) @binding(1)
var<storage, read> cellIndices: array<u32>;

struct ColorParams {
  mode: f32, // 0 = monochrome, 1 = velocity, 2 = cell
};

@group(0) @binding(2)
var<uniform> params: ColorParams;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let particleIdx = id.x;
  if (particleIdx >= arrayLength(&particles)) { return; }
  
  var p = particles[particleIdx];
  
  if (params.mode < 0.5) {
    // Mode 0: Monochrome (white)
    p.color = vec3<f32>(1.0, 1.0, 1.0);
  } else if (params.mode < 1.5) {
    // Mode 1: Velocity-based coloring
    let v = p.vel;
    let r = clamp(0.75 + v.x * 10.0, 0.5, 1.0);
    let g = clamp(0.75 + v.y * 10.0, 0.5, 1.0);
    let b = clamp(0.5 + (v.x + v.y) * 5.0, 0.5, 1.0);
    p.color = vec3<f32>(r, g, b);
  } else {
    // Mode 2: Cell-based coloring (for debugging)
    let cell = cellIndices[particleIdx];
    let gx = cell % CELLS_PER_DIRECTION;
    let gy = cell / CELLS_PER_DIRECTION;
    // Create a color based on grid position
    let r = fract(f32(gx) / 7.0);
    let g = fract(f32(gy) / 7.0);
    let b = fract(f32(cell) / 11.0);
    p.color = vec3<f32>(r, g, b);
  }
  
  particles[particleIdx] = p;
}
`;

const colorModule = device.createShaderModule({ code: colorShaderCode });
const colorPipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: colorModule, entryPoint: 'main' },
});

let colorBindGroup; // Will be created in initializeParticles()

//
// === Mouse Interaction Compute Shader (WGSL) ===
// Applies forces to particles within drag radius of mouse cursor
//
const mouseInteractionShaderCode = /* wgsl */`
struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
  color: vec3<f32>,
  _pad: f32, // Padding to align struct to 32 bytes (8 floats)
};

@group(0) @binding(0)
var<storage, read_write> particles: array<Particle>;

struct MouseParams {
  mousePos: vec2<f32>,      // Mouse position in particle coordinate space (-1 to 1)
  dragRadius: f32,          // Radius of influence
  dragStrength: f32,         // Strength of drag force
  isActive: f32,             // 1.0 if dragging, 0.0 otherwise
  torus: f32,                // 1.0 if torus mode, 0.0 otherwise
};

@group(0) @binding(1)
var<uniform> mouseParams: MouseParams;

// Helper function to calculate toroidal distance squared
fn toroidalDistSq(pos1: vec2<f32>, pos2: vec2<f32>) -> f32 {
  var dx = pos2.x - pos1.x;
  var dy = pos2.y - pos1.y;
  
  // Wrap distance components for torus
  if (abs(dx) > 1.0) {
    dx = dx - sign(dx) * 2.0;
  }
  if (abs(dy) > 1.0) {
    dy = dy - sign(dy) * 2.0;
  }
  
  return dx * dx + dy * dy;
}

// Helper function to calculate toroidal difference vector
fn toroidalDiff(pos1: vec2<f32>, pos2: vec2<f32>) -> vec2<f32> {
  var dx = pos2.x - pos1.x;
  var dy = pos2.y - pos1.y;
  
  // Wrap difference components for torus
  if (abs(dx) > 1.0) {
    dx = dx - sign(dx) * 2.0;
  }
  if (abs(dy) > 1.0) {
    dy = dy - sign(dy) * 2.0;
  }
  
  return vec2<f32>(dx, dy);
}

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let i = id.x;
  if (i >= arrayLength(&particles)) { return; }
  if (mouseParams.isActive < 0.5) { return; } // No interaction if not dragging
  
  var p = particles[i];
  
  // Calculate distance to mouse cursor
  let distSq = select(
    dot(p.pos - mouseParams.mousePos, p.pos - mouseParams.mousePos),
    toroidalDistSq(p.pos, mouseParams.mousePos),
    mouseParams.torus > 0.5
  );
  let radiusSq = mouseParams.dragRadius * mouseParams.dragRadius;
  
  // Apply force if within radius
  if (distSq < radiusSq) {
    // Calculate direction to mouse (using toroidal difference if needed)
    let diff = select(
      mouseParams.mousePos - p.pos,
      toroidalDiff(p.pos, mouseParams.mousePos),
      mouseParams.torus > 0.5
    );
    
    // Calculate distance
    let dist = sqrt(distSq);
    
    // Apply force proportional to distance (stronger closer to mouse)
    // Use inverse distance falloff for smoother interaction
    let forceStrength = mouseParams.dragStrength * (1.0 - dist / mouseParams.dragRadius);
    let force = normalize(diff) * forceStrength;
    
    // Apply force to velocity
    p.vel += force;
  }
  
  particles[i] = p;
}
`;

const mouseInteractionModule = device.createShaderModule({ code: mouseInteractionShaderCode });
const mouseInteractionPipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: mouseInteractionModule, entryPoint: 'main' },
});

//
// === Render Shader (WGSL) ===
//
const renderShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;

struct VSOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) color: vec4<f32>,
};

struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
  color: vec3<f32>,
  _pad: f32, // Padding to align struct to 32 bytes (8 floats)
};

@group(0) @binding(0)
var<storage, read> particles: array<Particle>;

@vertex
fn vs_main(@builtin(vertex_index) vid: u32) -> VSOut {
  var out: VSOut;
  let p = particles[vid];
  out.pos = vec4<f32>(p.pos, 0.0, 1.0);
  // Use the color stored in the particle
  out.color = vec4<f32>(p.color, 1.0);
  return out;
}

@fragment
fn fs_main(in: VSOut) -> @location(0) vec4<f32> {
  return in.color;
}

`;

const renderModule = device.createShaderModule({ code: renderShaderCode });
const renderPipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: {
    module: renderModule,
    entryPoint: 'vs_main',
  },
  fragment: {
    module: renderModule,
    entryPoint: 'fs_main',
    targets: [{ format }],
  },
  primitive: { topology: 'point-list' },
});

//
// === Grid Rendering Shader (WGSL) ===
//
const gridShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;
const CELL_SIZE = 2.0 / f32(CELLS_PER_DIRECTION);

struct VSOut {
  @builtin(position) pos: vec4<f32>,
};

@vertex
fn vs_main(@builtin(vertex_index) vid: u32) -> VSOut {
  var out: VSOut;
  
  // Generate grid lines: vertical and horizontal lines
  // Total vertices: 2 * (cellsPerDirection + 1) vertical lines * 2 vertices + 
  //                 2 * (cellsPerDirection + 1) horizontal lines * 2 vertices
  // = 4 * (cellsPerDirection + 1) vertices
  
  let totalVerticalVertices = 2u * (CELLS_PER_DIRECTION + 1u);
  let vertexInLine = vid % 2u;
  
  if (vid < totalVerticalVertices) {
    // Vertical lines
    let lineIndex = vid / 2u;
    let x = -1.0 + f32(lineIndex) * CELL_SIZE;
    var y: f32;
    if (vertexInLine == 0u) {
      y = -1.0;
    } else {
      y = 1.0;
    }
    out.pos = vec4<f32>(x, y, 0.0, 1.0);
  } else {
    // Horizontal lines
    let horizontalVid = vid - totalVerticalVertices;
    let lineIndex = horizontalVid / 2u;
    var x: f32;
    if (vertexInLine == 0u) {
      x = -1.0;
    } else {
      x = 1.0;
    }
    let y = -1.0 + f32(lineIndex) * CELL_SIZE;
    out.pos = vec4<f32>(x, y, 0.0, 1.0);
  }
  
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
  // Gray color for grid lines
  return vec4<f32>(0.3, 0.3, 0.3, 0.5);
}
`;

const gridModule = device.createShaderModule({ code: gridShaderCode });
const gridPipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: {
    module: gridModule,
    entryPoint: 'vs_main',
  },
  fragment: {
    module: gridModule,
    entryPoint: 'fs_main',
    targets: [{ format }],
  },
  primitive: { topology: 'line-list' },
});

//
// === Velocity Vector Rendering Shader (WGSL) ===
//
const velocityVectorShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;
const CELL_SIZE = 2.0 / f32(CELLS_PER_DIRECTION);
const HALF_CELL = CELL_SIZE * 0.5;
const VECTOR_SCALE = 100.0; // Scale factor for velocity vectors

struct VSOut {
  @builtin(position) pos: vec4<f32>,
};

@group(0) @binding(0)
var<storage, read> gridVelocities: array<vec2<f32>>;

@vertex
fn vs_main(@builtin(vertex_index) vid: u32,
           @builtin(instance_index) iid: u32) -> VSOut {
  var out: VSOut;
  
  // Get cell center position
  let gx = iid % CELLS_PER_DIRECTION;
  let gy = iid / CELLS_PER_DIRECTION;
  let cellCenterX = -1.0 + f32(gx) * CELL_SIZE + HALF_CELL;
  let cellCenterY = -1.0 + f32(gy) * CELL_SIZE + HALF_CELL;
  
  // Get grid velocity for this cell
  let vel = gridVelocities[iid];
  let velMagnitude = length(vel);
  
  // Draw line from center to center + velocity (scaled)
  if (vid == 0u) {
    // Start point: cell center
    out.pos = vec4<f32>(cellCenterX, cellCenterY, 0.0, 1.0);
  } else {
    // End point: center + velocity * scale
    let endX = cellCenterX + vel.x * VECTOR_SCALE;
    let endY = cellCenterY + vel.y * VECTOR_SCALE;
    out.pos = vec4<f32>(endX, endY, 0.0, 1.0);
  }
  
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
  // Yellow color for velocity vectors
  return vec4<f32>(1.0, 1.0, 0.0, 0.8);
}
`;

const velocityVectorModule = device.createShaderModule({ code: velocityVectorShaderCode });
const velocityVectorPipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: {
    module: velocityVectorModule,
    entryPoint: 'vs_main',
  },
  fragment: {
    module: velocityVectorModule,
    entryPoint: 'fs_main',
    targets: [{ format }],
  },
  primitive: { topology: 'line-list' },
});

// Create bind group for velocity vectors
const velocityVectorBindGroup = device.createBindGroup({
  layout: velocityVectorPipeline.getBindGroupLayout(0),
  entries: [
    { binding: 0, resource: { buffer: gridVelocityBuffer } },
  ],
});

//
// === Edge Rendering Shader (WGSL) ===
// Renders lines connecting particles to their neighbors
//
const edgeShaderCode = /* wgsl */`
const MAX_NEIGHBORS = ${MAX_NEIGHBORS}u;
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;

struct VSOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) color: vec4<f32>,
};

struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
  color: vec3<f32>,
  _pad: f32, // Padding to align struct to 32 bytes (8 floats)
};

@group(0) @binding(0)
var<storage, read> particles: array<Particle>;

@group(0) @binding(1)
var<storage, read> neighborIndices: array<u32>; // Flattened: numParticles * MAX_NEIGHBORS

@group(0) @binding(2)
var<storage, read> neighborCounts: array<u32>; // One per particle

struct Params {
  dt: f32,
  drag: f32,
  decay: f32,
  cohesion: f32,
  separationStrength: f32,
  separationDistance: f32,
  alignment: f32,
  coupleToGrid: f32,
  torus: f32, // 1.0 = true, 0.0 = false
};

@group(0) @binding(3)
var<uniform> params: Params;

// Helper function to wrap a position relative to a reference position (for torus mode)
// Returns the wrapped version of pos2 that is closest to pos1
fn wrapPositionRelative(pos1: vec2<f32>, pos2: vec2<f32>) -> vec2<f32> {
  var wrapped = pos2;
  var dx = pos2.x - pos1.x;
  var dy = pos2.y - pos1.y;
  
  // Wrap x component if needed (coordinate range is -1.0 to 1.0, width is 2.0)
  // If |dx| > 1.0, wrapping will make it closer
  if (dx > 1.0) {
    wrapped.x = pos2.x - 2.0;
  } else if (dx < -1.0) {
    wrapped.x = pos2.x + 2.0;
  }
  
  // Wrap y component if needed
  if (dy > 1.0) {
    wrapped.y = pos2.y - 2.0;
  } else if (dy < -1.0) {
    wrapped.y = pos2.y + 2.0;
  }
  
  return wrapped;
}

@vertex
fn vs_main(@builtin(vertex_index) vid: u32, @builtin(instance_index) instanceIdx: u32) -> VSOut {
  var out: VSOut;
  
  // Calculate which particle and which neighbor slot
  let particleIdx = instanceIdx / MAX_NEIGHBORS;
  let neighborSlot = instanceIdx % MAX_NEIGHBORS;
  
  // Check if this particle has a neighbor in this slot
  if (particleIdx >= arrayLength(&particles)) {
    // Degenerate line (both vertices at origin)
    out.pos = vec4<f32>(0.0, 0.0, 0.0, 1.0);
    out.color = vec4<f32>(0.0, 0.0, 0.0, 0.0);
    return out;
  }
  
  let numNeighbors = neighborCounts[particleIdx];
  if (neighborSlot >= numNeighbors) {
    // Degenerate line (both vertices at origin)
    out.pos = vec4<f32>(0.0, 0.0, 0.0, 1.0);
    out.color = vec4<f32>(0.0, 0.0, 0.0, 0.0);
    return out;
  }
  
  // Get neighbor index
  let baseIndex = particleIdx * MAX_NEIGHBORS;
  let neighborIdx = neighborIndices[baseIndex + neighborSlot];
  
  // Check if neighbor index is valid
  if (neighborIdx >= arrayLength(&particles) || neighborIdx == 0xFFFFFFFFu) {
    // Degenerate line (both vertices at origin)
    out.pos = vec4<f32>(0.0, 0.0, 0.0, 1.0);
    out.color = vec4<f32>(0.0, 0.0, 0.0, 0.0);
    return out;
  }
  
  // Get particle and neighbor positions
  let particle = particles[particleIdx];
  let neighbor = particles[neighborIdx];
  
  // Determine if this is the start (vid == 0) or end (vid == 1) vertex
  if (vid == 0u) {
    // Start vertex: particle position
    out.pos = vec4<f32>(particle.pos, 0.0, 1.0);
  } else {
    // End vertex: neighbor position (wrapped if torus mode)
    var neighborPos = neighbor.pos;
    if (params.torus > 0.5) {
      neighborPos = wrapPositionRelative(particle.pos, neighbor.pos);
    }
    out.pos = vec4<f32>(neighborPos, 0.0, 1.0);
  }
  
  // Use the color stored in the particle
  out.color = vec4<f32>(particle.color, 1.0);
  
  return out;
}

@fragment
fn fs_main(in: VSOut) -> @location(0) vec4<f32> {
  return in.color;
}
`;

const edgeModule = device.createShaderModule({ code: edgeShaderCode });
const edgePipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: {
    module: edgeModule,
    entryPoint: 'vs_main',
  },
  fragment: {
    module: edgeModule,
    entryPoint: 'fs_main',
    targets: [{ format }],
  },
  primitive: { topology: 'line-list' },
});

// edgeBindGroup is declared at the top level and created in initializeParticles()

// Track particle visibility
let showParticles = true;
const showParticlesCheckbox = document.getElementById('show-particles');
showParticlesCheckbox.addEventListener('change', (e) => {
  showParticles = e.target.checked;
});

// Track grid visibility
let showGrid = false;
const showGridCheckbox = document.getElementById('show-grid');
showGridCheckbox.addEventListener('change', (e) => {
  showGrid = e.target.checked;
});

// Track edge visibility
let showEdges = false;
const showEdgesCheckbox = document.getElementById('show-edges');
showEdgesCheckbox.addEventListener('change', (e) => {
  showEdges = e.target.checked;
});

// Track flocking state
let doFlocking = true; // Default to enabled
const doFlockingCheckbox = document.getElementById('do-flocking');
doFlockingCheckbox.addEventListener('change', (e) => {
  doFlocking = e.target.checked;
});

// Track grid coupling state
const coupleToGridCheckbox = document.getElementById('couple-to-grid');
coupleToGridCheckbox.addEventListener('change', (e) => {
  coupleToGrid = e.target.checked;
  // Update uniform buffer
  uniformData[7] = coupleToGrid ? 1.0 : 0.0;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
});

// Track torus state
const torusCheckbox = document.getElementById('torus');
torusCheckbox.addEventListener('change', (e) => {
  torus = e.target.checked;
  // Update uniform buffer
  uniformData[8] = torus ? 1.0 : 0.0;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
  // Update mouse params buffer
  mouseParamsData[5] = torus ? 1.0 : 0.0;
  device.queue.writeBuffer(mouseParamsBuffer, 0, mouseParamsData);
});

// Track drag radius
const dragRadiusInput = document.getElementById('drag-radius');
dragRadiusInput.value = mouseDragRadius;
dragRadiusInput.addEventListener('input', (e) => {
  mouseDragRadius = parseFloat(e.target.value);
  mouseParamsData[2] = mouseDragRadius;
  device.queue.writeBuffer(mouseParamsBuffer, 0, mouseParamsData);
});

// Track drag strength
const dragStrengthInput = document.getElementById('drag-strength');
dragStrengthInput.value = mouseDragStrength;
dragStrengthInput.addEventListener('input', (e) => {
  mouseDragStrength = parseFloat(e.target.value);
  mouseParamsData[3] = mouseDragStrength;
  device.queue.writeBuffer(mouseParamsBuffer, 0, mouseParamsData);
});

// Track color mode
const colorModeSelect = document.getElementById('color-mode');
colorModeSelect.addEventListener('change', (e) => {
  colorMode = parseInt(e.target.value);
  // Update color params buffer
  const colorParamsData = new Float32Array(1);
  colorParamsData[0] = colorMode;
  device.queue.writeBuffer(colorParamsBuffer, 0, colorParamsData);
});

// Track simulation running state
let simulationRunning = true;
const startStopBtn = document.getElementById('start-stop-btn');
startStopBtn.addEventListener('click', () => {
  simulationRunning = !simulationRunning;
  startStopBtn.textContent = simulationRunning ? 'Stop' : 'Start';
});

// Initialize particles (after pipelines are created)
initializeParticles();

// Mouse interaction event handlers
function screenToParticleCoords(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const x = ((clientX - rect.left) / rect.width) * 2.0 - 1.0;
  const y = 1.0 - ((clientY - rect.top) / rect.height) * 2.0; // Flip Y axis
  return { x, y };
}

function updateMouseParams() {
  mouseParamsData[0] = mousePos.x;
  mouseParamsData[1] = mousePos.y;
  mouseParamsData[2] = mouseDragRadius;
  mouseParamsData[3] = mouseDragStrength;
  mouseParamsData[4] = isMouseDragging ? 1.0 : 0.0;
  mouseParamsData[5] = torus ? 1.0 : 0.0;
  device.queue.writeBuffer(mouseParamsBuffer, 0, mouseParamsData);
}

canvas.addEventListener('mousedown', (e) => {
  isMouseDragging = true;
  mousePos = screenToParticleCoords(e.clientX, e.clientY);
  updateMouseParams();
  canvas.style.cursor = 'grabbing';
});

canvas.addEventListener('mousemove', (e) => {
  if (isMouseDragging) {
    mousePos = screenToParticleCoords(e.clientX, e.clientY);
    updateMouseParams();
  }
});

canvas.addEventListener('mouseup', (e) => {
  isMouseDragging = false;
  updateMouseParams();
  canvas.style.cursor = 'default';
});

canvas.addEventListener('mouseleave', (e) => {
  isMouseDragging = false;
  updateMouseParams();
  canvas.style.cursor = 'default';
});

// Touch support for mobile
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (e.touches.length > 0) {
    isMouseDragging = true;
    mousePos = screenToParticleCoords(e.touches[0].clientX, e.touches[0].clientY);
    updateMouseParams();
  }
});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (isMouseDragging && e.touches.length > 0) {
    mousePos = screenToParticleCoords(e.touches[0].clientX, e.touches[0].clientY);
    updateMouseParams();
  }
});

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  isMouseDragging = false;
  updateMouseParams();
});

canvas.addEventListener('touchcancel', (e) => {
  e.preventDefault();
  isMouseDragging = false;
  updateMouseParams();
});

// Control panel setup
const numParticlesInput = document.getElementById('num-particles');
numParticlesInput.value = numParticles; // Initialize input from JavaScript variable
const dragInput = document.getElementById('drag');
dragInput.value = drag; // Initialize input from JavaScript variable

const decayInput = document.getElementById('decay');
decayInput.value = decay;

const cohesionInput = document.getElementById('cohesion');
cohesionInput.value = cohesion;

const separationStrengthInput = document.getElementById('separation-strength');
separationStrengthInput.value = separationStrength;

const separationDistanceInput = document.getElementById('separation-distance');
separationDistanceInput.value = separationDistance;

const alignmentInput = document.getElementById('alignment');
alignmentInput.value = alignment;

function updatedrag(value) {
  drag = parseFloat(value);
  dragInput.value = drag;
  
  // Update uniform buffer
  uniformData[1] = drag;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
  console.log("Updated drag to ", drag);
}

dragInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const val = parseFloat(e.target.value);
    updatedrag(isNaN(val) ? 0.1 : val);
  }
});

function updateDecay(value) {
  decay = parseFloat(value);
  decayInput.value = decay;
  
  // Update uniform buffer
  uniformData[2] = decay;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
  console.log("Updated decay to ", decay);
}

function updateCohesion(value) {
  cohesion = parseFloat(value);
  cohesionInput.value = cohesion;
  
  // Update uniform buffer
  uniformData[3] = cohesion;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
  console.log("Updated cohesion to ", cohesion);
}

function updateSeparationStrength(value) {
  separationStrength = parseFloat(value);
  separationStrengthInput.value = separationStrength;
  
  // Update uniform buffer
  uniformData[4] = separationStrength;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
  console.log("Updated separation strength to ", separationStrength);
}

function updateSeparationDistance(value) {
  separationDistance = parseFloat(value);
  separationDistanceInput.value = separationDistance;
  
  // Update uniform buffer
  uniformData[5] = separationDistance;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
  console.log("Updated separation distance to ", separationDistance);
}

function updateAlignment(value) {
  alignment = parseFloat(value);
  alignmentInput.value = alignment;
  
  // Update uniform buffer
  uniformData[6] = alignment;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
  console.log("Updated alignment to ", alignment);
}

cohesionInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const val = parseFloat(e.target.value);
    updateCohesion(isNaN(val) ? 0.03 : val);
  }
});

separationStrengthInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const val = parseFloat(e.target.value);
    updateSeparationStrength(isNaN(val) ? 0.05 : val);
  }
});

separationDistanceInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const val = parseFloat(e.target.value);
    updateSeparationDistance(isNaN(val) ? 0.02 : val);
  }
});

alignmentInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const val = parseFloat(e.target.value);
    updateAlignment(isNaN(val) ? 0.009 : val);
  }
});

function restartSimulation() {
  // Stop current animation
  if (frameId !== null) {
    cancelAnimationFrame(frameId);
    frameId = null;
  }
  
  // Reset grid velocities
  const gridVelocityData = new Float32Array(numCells * 2);
  device.queue.writeBuffer(gridVelocityBuffer, 0, gridVelocityData);
  
  // Reinitialize particles with new count
  initializeParticles();
  
  // Restart animation
  frame();
}

numParticlesInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const newCount = Math.max(1000, Math.min(10000000, parseInt(e.target.value) || 1000000));
    if (newCount !== numParticles) {
      numParticles = newCount;
      numParticlesInput.value = numParticles;
      restartSimulation();
    }
  }
});

//
// === Frame loop ===
//
let lastTime = performance.now();
let frameCount = 0;
let fps = 0;
const fpsCounter = document.getElementById('fps-counter');
const energyCounter = document.getElementById('energy-counter');
let energyReadbackPending = false;
let lastEnergyReadTime = 0;
let neighborUpdateCounter = 0;
const NEIGHBOR_UPDATE_INTERVAL = 10; // Update neighbors every 10 frames

function frame() {
  const currentTime = performance.now();
  const deltaTime = currentTime - lastTime;
  frameCount++;
  
  // Update FPS every second
  if (deltaTime >= 1000) {
    fps = Math.round((frameCount * 1000) / deltaTime);
    fpsCounter.textContent = `FPS: ${fps}`;
    frameCount = 0;
    lastTime = currentTime;
  }
  
  const encoder = device.createCommandEncoder();
  let shouldReadEnergy = false;
  let shouldReadTimestamp = false;

  // Only run compute passes if simulation is running
  if (simulationRunning) {
    // Reset energy buffer to zero before compute
    device.queue.writeBuffer(energySumBuffer, 0, new Uint32Array([0]));
    
    // Reset particle count buffer to zero before compute
    device.queue.writeBuffer(particleCountBuffer, 0, new Uint32Array(numCells));

    // 0 Grid decay compute pass (runs once per frame)
    {
      const pass = encoder.beginComputePass();
      pass.setPipeline(gridDecayPipeline);
      pass.setBindGroup(0, gridDecayBindGroup);
      pass.dispatchWorkgroups(Math.ceil(numCells / 64)); // numCells workgroups
      pass.end();
    }

    // 1 Particle compute pass (with GPU timing)
    {
      const pass = createTimedComputePass(encoder, 0); // Use query indices 0-1
      pass.setPipeline(computePipeline);
      pass.setBindGroup(0, computeBindGroup);
      pass.dispatchWorkgroups(Math.ceil(numParticles / 64));
      pass.end();
    }

    // 1.5 Normalize grid velocities by particle count
    {
      const pass = encoder.beginComputePass();
      pass.setPipeline(normalizeVelocityPipeline);
      pass.setBindGroup(0, normalizeVelocityBindGroup);
      pass.dispatchWorkgroups(Math.ceil(numCells / 64));
      pass.end();
    }

    // 1.75 Find neighbors compute pass (runs periodically, every NEIGHBOR_UPDATE_INTERVAL frames)
    // Runs after particle compute so it uses fresh cell indices
    neighborUpdateCounter++;
    if (neighborUpdateCounter >= NEIGHBOR_UPDATE_INTERVAL) {
      neighborUpdateCounter = 0;
      
      // Reset particleCounts for building cell mapping (we'll reuse it)
      device.queue.writeBuffer(particleCountBuffer, 0, new Uint32Array(numCells));
      
      // Reset cellParticleLists to invalid indices
      const cellListResetData = new Uint32Array(numCells * window.MAX_PARTICLES_PER_CELL);
      cellListResetData.fill(0xFFFFFFFF); // Invalid marker (JavaScript, not WGSL)
      device.queue.writeBuffer(cellParticleListsBuffer, 0, cellListResetData);
      
      // Build cell-to-particle mapping (must run before findNeighbors)
      {
        const pass = encoder.beginComputePass();
        pass.setPipeline(buildCellMappingPipeline);
        pass.setBindGroup(0, buildCellMappingBindGroup);
        pass.dispatchWorkgroups(Math.ceil(numParticles / 64));
        pass.end();
      }
      
      // Now find neighbors using the optimized cell mapping
      {
        const pass = createTimedComputePass(encoder, 2); // Use query indices 2-3 for timing
        pass.setPipeline(findNeighborsPipeline);
        pass.setBindGroup(0, findNeighborsBindGroup);
        pass.dispatchWorkgroups(Math.ceil(numParticles / 64));
        pass.end();
      }
    }

    // 1.8 Flocking compute pass (applies cohesion, separation, alignment)
    if (doFlocking) {
      const pass = createTimedComputePass(encoder, 4); // Use query indices 4-5 for timing
      pass.setPipeline(flockingPipeline);
      pass.setBindGroup(0, flockingBindGroup);
      pass.dispatchWorkgroups(Math.ceil(numParticles / 64));
      pass.end();
    }

    // 1.9 Color compute pass (updates particle colors based on mode)
    {
      const pass = encoder.beginComputePass();
      pass.setPipeline(colorPipeline);
      pass.setBindGroup(0, colorBindGroup);
      pass.dispatchWorkgroups(Math.ceil(numParticles / 64));
      pass.end();
    }

    // 1.95 Mouse interaction compute pass (applies drag forces to particles)
    if (isMouseDragging && mouseInteractionBindGroup) {
      const pass = encoder.beginComputePass();
      pass.setPipeline(mouseInteractionPipeline);
      pass.setBindGroup(0, mouseInteractionBindGroup);
      pass.dispatchWorkgroups(Math.ceil(numParticles / 64));
      pass.end();
    }

    // Copy energy from GPU to staging buffer for readback (only when ready to read)
    shouldReadEnergy = !energyReadbackPending && (currentTime - lastEnergyReadTime >= 1000);
    if (shouldReadEnergy) {
      encoder.copyBufferToBuffer(energySumBuffer, 0, energyStagingBuffer, 0, 4);
      energyReadbackPending = true;
      lastEnergyReadTime = currentTime;
    }
    
    // Resolve timestamp queries if needed
    shouldReadTimestamp = resolveTimestamps(encoder, currentTime);
  }

  // 2 Render pass
  const textureView = context.getCurrentTexture().createView();
  const renderPass = encoder.beginRenderPass({
    colorAttachments: [{
      view: textureView,
      clearValue: { r: 0, g: 0, b: 0, a: 1 },
      loadOp: 'clear',
      storeOp: 'store',
    }],
  });
  
  // Render particles if enabled
  if (showParticles) {
    renderPass.setPipeline(renderPipeline);
    renderPass.setBindGroup(0, renderBindGroup);
    renderPass.draw(numParticles);
  }
  
  // Render edges (connections between particles and neighbors) if enabled
  if (showEdges && neighborIndicesBuffer) {
    renderPass.setPipeline(edgePipeline);
    renderPass.setBindGroup(0, edgeBindGroup);
    // Draw 2 vertices per edge, with numParticles * MAX_NEIGHBORS instances
    renderPass.draw(2, numParticles * MAX_NEIGHBORS, 0, 0);
  }
  
  // Render grid lines and velocity vectors if enabled
  if (showGrid) {
    renderPass.setPipeline(gridPipeline);
    // Draw grid lines: 2 * (cellsPerDirection + 1) lines, each with 2 vertices
    const gridVertices = 2 * 2 * (cellsPerDirection + 1);
    renderPass.draw(gridVertices);
    
    // Render velocity vectors
    renderPass.setPipeline(velocityVectorPipeline);
    renderPass.setBindGroup(0, velocityVectorBindGroup);
    // Draw one line (2 vertices) per cell, using instancing
    renderPass.draw(2, numCells, 0, 0);
  }
  
  renderPass.end();

  device.queue.submit([encoder.finish()]);
  
  // Read back timestamps asynchronously after submit
  if (shouldReadTimestamp && timestampStagingBuffer) {
    timestampStagingBuffer.mapAsync(GPUMapMode.READ).then(() => {
      const timestampArray = new BigUint64Array(timestampStagingBuffer.getMappedRange());
      
      // Get timestamp period (nanoseconds per tick)
      // Try different APIs as browser support varies
      let period = 1.0; // Default: 1 nanosecond per tick
      if (typeof device.queue.getTimestampPeriod === 'function') {
        period = device.queue.getTimestampPeriod();
      } else if (typeof device.getTimestampPeriod === 'function') {
        period = device.getTimestampPeriod();
      }
      // If period is not available, assume 1 nanosecond per tick (common default)
      
      // Calculate particle compute duration (queries 0-1)
      const particleStartTime = Number(timestampArray[0]);
      const particleEndTime = Number(timestampArray[1]);
      const particleDurationMs = (particleEndTime - particleStartTime) * period / 1_000_000;
      
      // Calculate findNeighbors duration (queries 2-3) if available
      let timingText = `Particle: ${particleDurationMs.toFixed(3)} ms`;
      if (timestampArray.length >= 4 && timestampArray[2] > 0 && timestampArray[3] > 0) {
        const findNeighborsStartTime = Number(timestampArray[2]);
        const findNeighborsEndTime = Number(timestampArray[3]);
        const findNeighborsDurationMs = (findNeighborsEndTime - findNeighborsStartTime) * period / 1_000_000;
        timingText += `<br>findNeighbors: ${findNeighborsDurationMs.toFixed(3)} ms`;
      }
      
      // Calculate flocking duration (queries 4-5) if available
      if (timestampArray.length >= 6 && timestampArray[4] > 0 && timestampArray[5] > 0) {
        const flockingStartTime = Number(timestampArray[4]);
        const flockingEndTime = Number(timestampArray[5]);
        const flockingDurationMs = (flockingEndTime - flockingStartTime) * period / 1_000_000;
        timingText += `<br>Flocking: ${flockingDurationMs.toFixed(3)} ms`;
      }
      
      timestampCounter.innerHTML = timingText;
      timestampStagingBuffer.unmap();
      timestampReadbackPending = false;
    }).catch(err => {
      console.error('Error reading timestamps:', err);
      timestampReadbackPending = false;
    });
  }
  
  // Read back energy asynchronously after submit (only once per second to avoid performance hit)
  if (shouldReadEnergy) {
    // Wait for the copy to complete before mapping
    energyStagingBuffer.mapAsync(GPUMapMode.READ).then(() => {
      const energyArray = new Uint32Array(energyStagingBuffer.getMappedRange());
      const energySum = energyArray[0];
      // Energy is stored as velSquared * 10000.0, so normalize by dividing by 10000.0 and numParticles
      const normalizedEnergy = energySum / (10000.0 * numParticles);
      energyCounter.textContent = `Energy: ${normalizedEnergy.toFixed(6)}`;
      energyStagingBuffer.unmap();
      energyReadbackPending = false;
    }).catch(err => {
      console.error('Error reading energy:', err);
      energyReadbackPending = false;
    });
  }
  
  frameId = requestAnimationFrame(frame);
}

frame();
</script>
</body>
</html>