<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WebGPU Compute Particles</title>
<style>
  body {
    display: flex;
    margin: 0;
    padding: 0;
    background: #1a1a1a;
  }
  #control-panel {
    width: 200px;
    padding: 20px;
    background: #2a2a2a;
    color: white;
    font-family: Arial, sans-serif;
    font-size: 14px;
  }
  #control-panel h3 {
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 16px;
  }
  .control-group {
    margin-bottom: 10px;
  }
  .control-group label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    color: #ccc;
  }
  .control-group input[type="range"] {
    width: 100%;
  }
  .control-group input[type="number"] {
    flex: 1;
    padding: 5px;
    background: #1a1a1a;
    color: white;
    border: 1px solid #444;
    border-radius: 3px;
    font-size: 12px;
  }
  canvas { width: 1000px; height: 1000px; display: block; background: black; }
  #fps-counter {
    position: fixed;
    bottom: 30px;
    right: 10px;
    color: white;
    font-family: monospace;
    font-size: 12px;
  }
  #energy-counter {
    position: fixed;
    bottom: 10px;
    right: 10px;
    color: white;
    font-family: monospace;
    font-size: 12px;
    background: rgba(0, 0, 0, 0.5);
    padding: 4px 8px;
    border-radius: 4px;
  }
</style>
</head>
<body>
<div id="control-panel">
  <h3>Controls</h3>
  <div class="control-group">
    <label for="num-particles">Number of Particles: <input type="number" id="num-particles" min="1000" max="10000000" step="1000" value="1000000"></label>
  </div>
  <div class="control-group">
    <label for="decay-factor">Decay Strength: <input type="number" id="decay-factor" min="0.0" max="1.0" step="0.01" value="0.99"></label>
  </div>
  <div class="control-group">
    <label for="show-particles">
      <input type="checkbox" id="show-particles" checked>
      Show Particles
    </label>
  </div>
  <div class="control-group">
    <label for="show-grid">
      <input type="checkbox" id="show-grid">
      Show Grid
    </label>
  </div>
  <div class="control-group">
    <button id="start-stop-btn" style="padding: 8px 16px; font-size: 14px; cursor: pointer;">Stop</button>
  </div>
</div>
<canvas id="gfx" width="1000" height="1000"></canvas>
<div id="fps-counter">FPS: --</div>
<div id="energy-counter">Energy: --</div>
<script type="module">
console.log('Startup');
const adapter = await navigator.gpu.requestAdapter();
console.log('Got Adapter');
const device = await adapter.requestDevice();
console.log('Got Device');
const canvas = document.getElementById('gfx');
const context = canvas.getContext('webgpu');
console.log('Got Got WebGPU context');

const format = navigator.gpu.getPreferredCanvasFormat();
context.configure({ device, format });

let numParticles = 1000000;
let particleBuffer, cellIndexBuffer, computeBindGroup, renderBindGroup;
let frameId = null;



function initializeParticles() {
  // JS-side data
  const particleData = new Float32Array(numParticles * 4); // x, y, vx, vy
  for (let i = 0; i < numParticles; i++) {
    particleData[i * 4 + 0] = (Math.random() * 2 - 1) * 0.9;  // x
    particleData[i * 4 + 1] = (Math.random() * 2 - 1) * 0.9;  // y
    particleData[i * 4 + 2] = (Math.random() * 2 - 1) * 0.1;  // vx
    particleData[i * 4 + 3] = (Math.random() * 2 - 1) * 0.1;  // vy
  }

  // GPU buffers
  if (particleBuffer) {
    particleBuffer.destroy();
  }
  particleBuffer = device.createBuffer({
    size: particleData.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(particleBuffer, 0, particleData);
  console.log('Wrote particle buffer to GPU');

  if (cellIndexBuffer) {
    cellIndexBuffer.destroy();
  }
  cellIndexBuffer = device.createBuffer({
    size: numParticles * 4, // one u32 per particle
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });
  
  // Recreate bind groups with new buffers
  computeBindGroup = device.createBindGroup({
    layout: computePipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: particleBuffer } },
      { binding: 1, resource: { buffer: cellIndexBuffer } },
      { binding: 2, resource: { buffer: uniformBuffer } },
      { binding: 3, resource: { buffer: gridVelocityBuffer } },
      { binding: 4, resource: { buffer: energySumBuffer } },
      { binding: 5, resource: { buffer: particleCountBuffer } },
    ],
  });
  
  renderBindGroup = device.createBindGroup({
    layout: renderPipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: particleBuffer } },
      { binding: 1, resource: { buffer: cellIndexBuffer } },
    ],
  });
}

// Grid configuration: cells per direction
const cellsPerDirection = 20;
const numCells = cellsPerDirection * cellsPerDirection;
const gridVelocityData = new Float32Array(numCells * 2); // Initialize to zero
const gridVelocityBuffer = device.createBuffer({
  size: gridVelocityData.byteLength,
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
});
device.queue.writeBuffer(gridVelocityBuffer, 0, gridVelocityData);
console.log('Created grid velocity buffer');

// Particle count buffer: one u32 per cell
const particleCountBuffer = device.createBuffer({
  size: numCells * 4, // one u32 (4 bytes) per cell
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
});
// Initialize to zero
device.queue.writeBuffer(particleCountBuffer, 0, new Uint32Array(numCells));
console.log('Created particle count buffer');


let drag = 1.0;
 
let dt = 0.016;

/*
const uniformData = new Float32Array([
  dt, 0, 0, 0,     // dt + pad (16 bytes)
  Gx, Gy, 0, 0,    // gravity (x,y) + pad (16 bytes)
  drag, 0, 0, 0,  // decay factor + pad (16 bytes)
  0, 0, 0, 0,         // additional pad to reach 80 bytes minimum (16 bytes)
  0, 0, 0, 0,
  0, 0, 0, 0,
]);
*/
const uniformData = new Float32Array(24);
uniformData[0] = dt;
uniformData[1] = drag;

const uniformBuffer = device.createBuffer({
  size: uniformData.byteLength,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
});
device.queue.writeBuffer(uniformBuffer, 0, uniformData);
console.log('Wrote uniform buffer to GPU');

// Energy sum buffer (atomic u32)
const energySumBuffer = device.createBuffer({
  size: 4, // single u32
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
});

// Staging buffer to read back energy
const energyStagingBuffer = device.createBuffer({
  size: 4,
  usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
});

// Initialize energy buffer to zero
device.queue.writeBuffer(energySumBuffer, 0, new Uint32Array([0]));
console.log('Created energy sum buffer');

//
// === Compute Shader (WGSL) ===
//
const computeShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;
const CELL_SIZE = 2.0 / f32(CELLS_PER_DIRECTION);
const MAX_CELL_INDEX = ${cellsPerDirection - 1}u;

struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
};

@group(0) @binding(0)
var<storage, read_write> particles: array<Particle>;

@group(0) @binding(1)
var<storage, read_write> cellIndices: array<u32>;

@group(0) @binding(3)
var<storage, read_write> gridVelocities: array<vec2<f32>>;

@group(0) @binding(4)
var<storage, read_write> energySum: atomic<u32>;

@group(0) @binding(5)
var<storage, read_write> particleCounts: array<atomic<u32>>;

struct Params {
  dt: f32,
  drag: f32,
};

@group(0) @binding(2)
var<uniform> params: Params;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let i = id.x;
  if (i >= arrayLength(&particles)) { return; }

  var p = particles[i];

  // --- physics ---
  p.pos += p.vel * params.dt;

  // bounce
  if (abs(p.pos.x) > 1.0) { p.vel.x = -p.vel.x; }
  if (abs(p.pos.y) > 1.0) { p.vel.y = -p.vel.y; }

  // --- grid assignment ---
  let gx = clamp(floor((p.pos.x + 1.0) / CELL_SIZE), 0.0, f32(MAX_CELL_INDEX));
  let gy = clamp(floor((p.pos.y + 1.0) / CELL_SIZE), 0.0, f32(MAX_CELL_INDEX));
  let cellIndex = u32(gy * f32(CELLS_PER_DIRECTION) + gx);
  cellIndices[i] = cellIndex;

  // Count particle in this cell (atomic increment)
  atomicAdd(&particleCounts[cellIndex], 1u);

  // --- grid-particle interaction ---
  let gridVel = gridVelocities[cellIndex];
  let particleVelBefore = p.vel; // Store original particle velocity
  
  // Add grid velocity to particle velocity
  let gridVelMagnitude = length(gridVel);
  if (gridVelMagnitude > 0.0) {
    p.vel += normalize(gridVel) * (0.001 * gridVelMagnitude);
  }
  
  // Accumulate particle velocity contribution to grid (will be normalized by count later)
  gridVelocities[cellIndex] = gridVel + particleVelBefore * 0.1;

  // Apply decay proportional to square of velocity
  let velSquared = dot(p.vel, p.vel);
  
  p.vel *= (1.0 - velSquared * params.drag); // Clamp to prevent negative or excessive decay
  //p.vel.x = clamp(p.vel.x, -1.0, 1.0);
  //p.vel.y = clamp(p.vel.y, -1.0, 1.0);
  
  // Accumulate energy (velocity^2) atomically
  // Convert velSquared (0.0-1.0) to u32 in range 1-100
  let energyValue = u32(velSquared * 10000.0);  
  atomicAdd(&energySum, energyValue);
  
  particles[i] = p;
}

`;

const computeModule = device.createShaderModule({ code: computeShaderCode });
const computePipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: computeModule, entryPoint: 'main' },
});

//
// === Grid Decay Compute Shader (WGSL) ===
//
const gridDecayShaderCode = /* wgsl */`
@group(0) @binding(3)
var<storage, read_write> gridVelocities: array<vec2<f32>>;

struct Params {
  dt: f32,
  drag: f32,
};
@group(0) @binding(2)
var<uniform> params: Params;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let i = id.x;
  if (i >= arrayLength(&gridVelocities)) { return; }
  
  // Apply decay factor to grid velocity
  gridVelocities[i] *= params.drag;
}

`;

const gridDecayModule = device.createShaderModule({ code: gridDecayShaderCode });
const gridDecayPipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: gridDecayModule, entryPoint: 'main' },
});
const gridDecayBindGroup = device.createBindGroup({
  layout: gridDecayPipeline.getBindGroupLayout(0),
  entries: [
    { binding: 2, resource: { buffer: uniformBuffer } },
    { binding: 3, resource: { buffer: gridVelocityBuffer } },
  ],
});

//
// === Velocity Normalization Compute Shader (WGSL) ===
//
const normalizeVelocityShaderCode = /* wgsl */`
@group(0) @binding(0)
var<storage, read_write> gridVelocities: array<vec2<f32>>;

@group(0) @binding(1)
var<storage, read_write> particleCounts: array<atomic<u32>>;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let i = id.x;
  if (i >= arrayLength(&gridVelocities)) { return; }
  
  // Get particle count for this cell
  let count = f32(atomicLoad(&particleCounts[i]));
  
  // Normalize velocity by particle count (avoid division by zero)
  if (count > 0.0) {
    gridVelocities[i] = gridVelocities[i] / count;
  } else {
    gridVelocities[i] = vec2<f32>(0.0, 0.0);
  }
}
`;

const normalizeVelocityModule = device.createShaderModule({ code: normalizeVelocityShaderCode });
const normalizeVelocityPipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: normalizeVelocityModule, entryPoint: 'main' },
});

const normalizeVelocityBindGroup = device.createBindGroup({
  layout: normalizeVelocityPipeline.getBindGroupLayout(0),
  entries: [
    { binding: 0, resource: { buffer: gridVelocityBuffer } },
    { binding: 1, resource: { buffer: particleCountBuffer } },
  ],
});

// computeBindGroup will be created in initializeParticles()

//
// === Render Shader (WGSL) ===
//
const renderShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;

struct VSOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) color: vec4<f32>,
};

@group(0) @binding(0)
var<storage, read> particles: array<vec4<f32>>; // pos+vel packed

@group(0) @binding(1)
var<storage, read> cellIndices: array<u32>;

@vertex
fn vs_main(@builtin(vertex_index) vid: u32) -> VSOut {
  var out: VSOut;
  let p = particles[vid];
  out.pos = vec4<f32>(p.xy, 0.0, 1.0);

  let cell = cellIndices[vid];
  let gx = cell % CELLS_PER_DIRECTION;
  let gy = cell / CELLS_PER_DIRECTION;
  // Create color
  let v = p.zw;
  let velSquared = dot(v, v);
  let r =  clamp(0.5 + v.x * 100.0, 0.0, 1.0);   // f32(gx) / 9.0;
  let g =  clamp(0.5 + v.y * 100.0, 0.0, 1.0);   //f32(gy) / 9.0;
  let b =  clamp(0.5 + (v.x + v.y) * 100.0, 0.0, 1.0);   // fract(f32(cell) / 7.0); // Add some variation
  out.color = vec4<f32>(r, g, b, 1.0);
  return out;
}

@fragment
fn fs_main(in: VSOut) -> @location(0) vec4<f32> {
  return in.color;
}

`;

const renderModule = device.createShaderModule({ code: renderShaderCode });
const renderPipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: {
    module: renderModule,
    entryPoint: 'vs_main',
  },
  fragment: {
    module: renderModule,
    entryPoint: 'fs_main',
    targets: [{ format }],
  },
  primitive: { topology: 'point-list' },
});

//
// === Grid Rendering Shader (WGSL) ===
//
const gridShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;
const CELL_SIZE = 2.0 / f32(CELLS_PER_DIRECTION);

struct VSOut {
  @builtin(position) pos: vec4<f32>,
};

@vertex
fn vs_main(@builtin(vertex_index) vid: u32) -> VSOut {
  var out: VSOut;
  
  // Generate grid lines: vertical and horizontal lines
  // Total vertices: 2 * (cellsPerDirection + 1) vertical lines * 2 vertices + 
  //                 2 * (cellsPerDirection + 1) horizontal lines * 2 vertices
  // = 4 * (cellsPerDirection + 1) vertices
  
  let totalVerticalVertices = 2u * (CELLS_PER_DIRECTION + 1u);
  let vertexInLine = vid % 2u;
  
  if (vid < totalVerticalVertices) {
    // Vertical lines
    let lineIndex = vid / 2u;
    let x = -1.0 + f32(lineIndex) * CELL_SIZE;
    var y: f32;
    if (vertexInLine == 0u) {
      y = -1.0;
    } else {
      y = 1.0;
    }
    out.pos = vec4<f32>(x, y, 0.0, 1.0);
  } else {
    // Horizontal lines
    let horizontalVid = vid - totalVerticalVertices;
    let lineIndex = horizontalVid / 2u;
    var x: f32;
    if (vertexInLine == 0u) {
      x = -1.0;
    } else {
      x = 1.0;
    }
    let y = -1.0 + f32(lineIndex) * CELL_SIZE;
    out.pos = vec4<f32>(x, y, 0.0, 1.0);
  }
  
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
  // Gray color for grid lines
  return vec4<f32>(0.3, 0.3, 0.3, 0.5);
}
`;

const gridModule = device.createShaderModule({ code: gridShaderCode });
const gridPipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: {
    module: gridModule,
    entryPoint: 'vs_main',
  },
  fragment: {
    module: gridModule,
    entryPoint: 'fs_main',
    targets: [{ format }],
  },
  primitive: { topology: 'line-list' },
});

//
// === Velocity Vector Rendering Shader (WGSL) ===
//
const velocityVectorShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;
const CELL_SIZE = 2.0 / f32(CELLS_PER_DIRECTION);
const HALF_CELL = CELL_SIZE * 0.5;
const VECTOR_SCALE = 100.0; // Scale factor for velocity vectors

struct VSOut {
  @builtin(position) pos: vec4<f32>,
};

@group(0) @binding(0)
var<storage, read> gridVelocities: array<vec2<f32>>;

@vertex
fn vs_main(@builtin(vertex_index) vid: u32,
           @builtin(instance_index) iid: u32) -> VSOut {
  var out: VSOut;
  
  // Get cell center position
  let gx = iid % CELLS_PER_DIRECTION;
  let gy = iid / CELLS_PER_DIRECTION;
  let cellCenterX = -1.0 + f32(gx) * CELL_SIZE + HALF_CELL;
  let cellCenterY = -1.0 + f32(gy) * CELL_SIZE + HALF_CELL;
  
  // Get grid velocity for this cell
  let vel = gridVelocities[iid];
  let velMagnitude = length(vel);
  
  // Draw line from center to center + velocity (scaled)
  if (vid == 0u) {
    // Start point: cell center
    out.pos = vec4<f32>(cellCenterX, cellCenterY, 0.0, 1.0);
  } else {
    // End point: center + velocity * scale
    let endX = cellCenterX + vel.x * VECTOR_SCALE;
    let endY = cellCenterY + vel.y * VECTOR_SCALE;
    out.pos = vec4<f32>(endX, endY, 0.0, 1.0);
  }
  
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
  // Yellow color for velocity vectors
  return vec4<f32>(1.0, 1.0, 0.0, 0.8);
}
`;

const velocityVectorModule = device.createShaderModule({ code: velocityVectorShaderCode });
const velocityVectorPipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: {
    module: velocityVectorModule,
    entryPoint: 'vs_main',
  },
  fragment: {
    module: velocityVectorModule,
    entryPoint: 'fs_main',
    targets: [{ format }],
  },
  primitive: { topology: 'line-list' },
});

// Create bind group for velocity vectors
const velocityVectorBindGroup = device.createBindGroup({
  layout: velocityVectorPipeline.getBindGroupLayout(0),
  entries: [
    { binding: 0, resource: { buffer: gridVelocityBuffer } },
  ],
});

// Track particle visibility
let showParticles = true;
const showParticlesCheckbox = document.getElementById('show-particles');
showParticlesCheckbox.addEventListener('change', (e) => {
  showParticles = e.target.checked;
});

// Track grid visibility
let showGrid = false;
const showGridCheckbox = document.getElementById('show-grid');
showGridCheckbox.addEventListener('change', (e) => {
  showGrid = e.target.checked;
});

// Track simulation running state
let simulationRunning = true;
const startStopBtn = document.getElementById('start-stop-btn');
startStopBtn.addEventListener('click', () => {
  simulationRunning = !simulationRunning;
  startStopBtn.textContent = simulationRunning ? 'Stop' : 'Start';
});

// Initialize particles (after pipelines are created)
initializeParticles();

// Control panel setup
const numParticlesInput = document.getElementById('num-particles');
const dragInput = document.getElementById('decay-factor');
dragInput.value = drag; // Initialize input from JavaScript variable

function updatedrag(value) {
  drag = parseFloat(value);
  dragInput.value = drag;
  
  // Update uniform buffer
  uniformData[2] = drag; // Index 12 is where drag is stored
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
  console.log("Updated drag to ", drag);
}

dragInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const val = Math.max(0.0, Math.min(10.0, parseFloat(e.target.value) || 0.1));
    updatedrag(val);
  }
});

function restartSimulation() {
  // Stop current animation
  if (frameId !== null) {
    cancelAnimationFrame(frameId);
    frameId = null;
  }
  
  // Reset grid velocities
  const gridVelocityData = new Float32Array(numCells * 2);
  device.queue.writeBuffer(gridVelocityBuffer, 0, gridVelocityData);
  
  // Reinitialize particles with new count
  initializeParticles();
  
  // Restart animation
  frame();
}

numParticlesInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const newCount = Math.max(1000, Math.min(10000000, parseInt(e.target.value) || 1000000));
    if (newCount !== numParticles) {
      numParticles = newCount;
      numParticlesInput.value = numParticles;
      restartSimulation();
    }
  }
});

//
// === Frame loop ===
//
let lastTime = performance.now();
let frameCount = 0;
let fps = 0;
const fpsCounter = document.getElementById('fps-counter');
const energyCounter = document.getElementById('energy-counter');
let energyReadbackPending = false;
let lastEnergyReadTime = 0;

function frame() {
  const currentTime = performance.now();
  const deltaTime = currentTime - lastTime;
  frameCount++;
  
  // Update FPS every second
  if (deltaTime >= 1000) {
    fps = Math.round((frameCount * 1000) / deltaTime);
    fpsCounter.textContent = `FPS: ${fps}`;
    frameCount = 0;
    lastTime = currentTime;
  }
  
  const encoder = device.createCommandEncoder();
  let shouldReadEnergy = false;

  // Only run compute passes if simulation is running
  if (simulationRunning) {
    // Reset energy buffer to zero before compute
    device.queue.writeBuffer(energySumBuffer, 0, new Uint32Array([0]));
    
    // Reset particle count buffer to zero before compute
    device.queue.writeBuffer(particleCountBuffer, 0, new Uint32Array(numCells));

    // 0️⃣ Grid decay compute pass (runs once per frame)
    {
      const pass = encoder.beginComputePass();
      pass.setPipeline(gridDecayPipeline);
      pass.setBindGroup(0, gridDecayBindGroup);
      pass.dispatchWorkgroups(Math.ceil(numCells / 64)); // numCells workgroups
      pass.end();
    }

    // 1️⃣ Particle compute pass
    {
      const pass = encoder.beginComputePass();
      pass.setPipeline(computePipeline);
      pass.setBindGroup(0, computeBindGroup);
      pass.dispatchWorkgroups(Math.ceil(numParticles / 64));
      pass.end();
    }

    // 1.5️⃣ Normalize grid velocities by particle count
    {
      const pass = encoder.beginComputePass();
      pass.setPipeline(normalizeVelocityPipeline);
      pass.setBindGroup(0, normalizeVelocityBindGroup);
      pass.dispatchWorkgroups(Math.ceil(numCells / 64));
      pass.end();
    }

    // Copy energy from GPU to staging buffer for readback (only when ready to read)
    shouldReadEnergy = !energyReadbackPending && (currentTime - lastEnergyReadTime >= 1000);
    if (shouldReadEnergy) {
      encoder.copyBufferToBuffer(energySumBuffer, 0, energyStagingBuffer, 0, 4);
      energyReadbackPending = true;
      lastEnergyReadTime = currentTime;
    }
  }

  // 2️⃣ Render pass
  const textureView = context.getCurrentTexture().createView();
  const renderPass = encoder.beginRenderPass({
    colorAttachments: [{
      view: textureView,
      clearValue: { r: 0, g: 0, b: 0, a: 1 },
      loadOp: 'clear',
      storeOp: 'store',
    }],
  });
  
  // Render particles if enabled
  if (showParticles) {
    renderPass.setPipeline(renderPipeline);
    renderPass.setBindGroup(0, renderBindGroup);
    renderPass.draw(numParticles);
  }
  
  // Render grid lines and velocity vectors if enabled
  if (showGrid) {
    renderPass.setPipeline(gridPipeline);
    // Draw grid lines: 2 * (cellsPerDirection + 1) lines, each with 2 vertices
    const gridVertices = 2 * 2 * (cellsPerDirection + 1);
    renderPass.draw(gridVertices);
    
    // Render velocity vectors
    renderPass.setPipeline(velocityVectorPipeline);
    renderPass.setBindGroup(0, velocityVectorBindGroup);
    // Draw one line (2 vertices) per cell, using instancing
    renderPass.draw(2, numCells, 0, 0);
  }
  
  renderPass.end();

  device.queue.submit([encoder.finish()]);
  
  // Read back energy asynchronously after submit (only once per second to avoid performance hit)
  if (shouldReadEnergy) {
    // Wait for the copy to complete before mapping
    energyStagingBuffer.mapAsync(GPUMapMode.READ).then(() => {
      const energyArray = new Uint32Array(energyStagingBuffer.getMappedRange());
      const energySum = energyArray[0];
      // Energy is stored as velSquared * 10000.0, so normalize by dividing by 10000.0 and numParticles
      const normalizedEnergy = energySum / (10000.0 * numParticles);
      energyCounter.textContent = `Energy: ${normalizedEnergy.toFixed(6)}`;
      energyStagingBuffer.unmap();
      energyReadbackPending = false;
    }).catch(err => {
      console.error('Error reading energy:', err);
      energyReadbackPending = false;
    });
  }
  
  frameId = requestAnimationFrame(frame);
}

frame();
</script>
</body>
</html>