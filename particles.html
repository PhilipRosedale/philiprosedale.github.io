<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WebGPU Compute Particles</title>

<!-- experiments -->    
<!--  Add list of neighbors to particle structure -->
<!--  Flocking, with N nearest neighbors rather than grid  -->
<!--  Add coupling constant between grid and particles to control panel -->
<!--  Add firing state, firing behavior, weights for N neighbors to particle -->
<!--  Add letters i/o capability to particles  -->
<!--    -->
<style>
  body {
    display: flex;
    margin: 0;
    padding: 0;
    background: #1a1a1a;
  }
  #control-panel {
    width: 200px;
    padding: 20px;
    background: #2a2a2a;
    color: white;
    font-family: Arial, sans-serif;
    font-size: 14px;
  }
  #control-panel h3 {
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 16px;
  }
  .control-group {
    margin-bottom: 10px;
  }
  .control-group label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    color: #ccc;
  }
  .control-group input[type="range"] {
    width: 100%;
  }
  .control-group input[type="number"] {
    flex: 1;
    padding: 5px;
    background: #1a1a1a;
    color: white;
    border: 1px solid #444;
    border-radius: 3px;
    font-size: 12px;
  }
  canvas { width: 1000px; height: 1000px; display: block; background: black; }
  #fps-counter {
    position: fixed;
    bottom: 30px;
    right: 10px;
    color: white;
    font-family: monospace;
    font-size: 12px;
  }
  #energy-counter {
    position: fixed;
    bottom: 10px;
    right: 10px;
    color: white;
    font-family: monospace;
    font-size: 12px;
    background: rgba(0, 0, 0, 0.5);
    padding: 4px 8px;
    border-radius: 4px;
  }
  #timestamp-counter {
    position: fixed;
    bottom: 50px;
    right: 10px;
    color: white;
    font-family: monospace;
    font-size: 12px;
    background: rgba(0, 0, 0, 0.5);
    padding: 4px 8px;
    border-radius: 4px;
  }
</style>
</head>
<body>
<div id="control-panel">
  <h3>Controls</h3>
  <div class="control-group">
    <label for="num-particles">Number of Particles: <input type="number" id="num-particles" min="1000" max="10000000" step="1000"></label>
  </div>
  <div class="control-group">
    <label for="drag">Drag: <input type="number" id="drag" step="0.01" value="0.99"></label>
  </div>
  <div class="control-group">
    <label for="decay">Decay: <input type="number" id="decay" step="0.01" value="0.99"></label>
  </div>
  <div class="control-group">
    <label for="show-particles">
      <input type="checkbox" id="show-particles" checked>
      Show Particles
    </label>
  </div>
  <div class="control-group">
    <label for="show-grid">
      <input type="checkbox" id="show-grid">
      Show Grid
    </label>
  </div>
  <div class="control-group">
    <label for="do-flocking">
      <input type="checkbox" id="do-flocking" checked>
      Do Flocking
    </label>
  </div>
  <div class="control-group">
    <label for="monochrome">
      <input type="checkbox" id="monochrome">
      Monochrome
    </label>
  </div>
  <div class="control-group">
    <label for="couple-to-grid">
      <input type="checkbox" id="couple-to-grid" checked>
      Couple to Grid
    </label>
  </div>
  <div class="control-group">
    <label for="cohesion">Cohesion: <input type="number" id="cohesion" step="0.001" value="0.03"></label>
  </div>
  <div class="control-group">
    <label for="separation-strength">Separation Strength: <input type="number" id="separation-strength" step="0.001" value="0.05"></label>
  </div>
  <div class="control-group">
    <label for="separation-distance">Separation Distance: <input type="number" id="separation-distance" step="0.001" value="0.02"></label>
  </div>
  <div class="control-group">
    <label for="alignment">Alignment: <input type="number" id="alignment" step="0.001" value="0.009"></label>
  </div>
  <div class="control-group">
    <button id="start-stop-btn" style="padding: 8px 16px; font-size: 14px; cursor: pointer;">Stop</button>
  </div>
</div>
<canvas id="gfx" width="1000" height="1000"></canvas>
<div id="fps-counter">FPS: --</div>
<div id="energy-counter">Energy: --</div>
<div id="timestamp-counter">GPU Timing: --</div>
<script type="module">
console.log('Startup');
const adapter = await navigator.gpu.requestAdapter();
console.log('Got Adapter');

// Check for timestamp query support
const requiredFeatures = [];
if (adapter.features.has('timestamp-query')) {
  requiredFeatures.push('timestamp-query');
  console.log('Timestamp queries supported');
} else {
  console.warn('Timestamp queries not supported - GPU timing will not be available');
}

const device = await adapter.requestDevice({ requiredFeatures });
console.log('Got Device');
const canvas = document.getElementById('gfx');
const context = canvas.getContext('webgpu');
console.log('Got Got WebGPU context');

const format = navigator.gpu.getPreferredCanvasFormat();
context.configure({ device, format });

let numParticles = 10000;
const MAX_NEIGHBORS = 16; // Maximum number of neighbors per particle for flocking
let particleBuffer, cellIndexBuffer, computeBindGroup, renderBindGroup;
let neighborIndicesBuffer, neighborCountBuffer; // Neighbor list buffers
let renderParamsBuffer; // Uniform buffer for render parameters (monochrome flag)
let cellParticleListsBuffer; // Maps cells to particle indices for fast neighbor lookup
let frameId = null;

// Timestamp query infrastructure for GPU timing
let timestampQuerySet = null;
let timestampBuffer = null;
let timestampReadbackPending = false;
let lastTimestampReadTime = 0;
const TIMESTAMP_READ_INTERVAL = 1000; // Read timestamps every second
const timestampCounter = document.getElementById('timestamp-counter');

// Initialize timestamp query set if supported
if (device.features.has('timestamp-query')) {
  // Create query set with 6 queries: 
  // 0-1: particle compute (start, end)
  // 2-3: findNeighbors (start, end)
  // 4-5: flocking (start, end)
  timestampQuerySet = device.createQuerySet({
    type: 'timestamp',
    count: 6,
  });
  
  // Create buffer to read back timestamps (6 u64 values = 48 bytes)
  timestampBuffer = device.createBuffer({
    size: 48,
    usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
  });
  
  console.log('Created timestamp query infrastructure');
}

// Helper function to create a compute pass with timestamp queries
// queryIndexOffset: 0 for particle compute, 2 for findNeighbors
function createTimedComputePass(encoder, queryIndexOffset = 0) {
  if (!timestampQuerySet) {
    // Timestamp queries not supported, return normal pass
    return encoder.beginComputePass();
  }
  
  // Create compute pass with timestamp writes
  return encoder.beginComputePass({
    timestampWrites: {
      querySet: timestampQuerySet,
      beginningOfPassWriteIndex: queryIndexOffset,
      endOfPassWriteIndex: queryIndexOffset + 1,
    },
  });
}

// Function to resolve and read back timestamps
function resolveTimestamps(encoder, currentTime) {
  if (!timestampQuerySet || !timestampBuffer || !timestampStagingBuffer) {
    return false;
  }
  
  const shouldReadTimestamp = !timestampReadbackPending && 
                               (currentTime - lastTimestampReadTime >= TIMESTAMP_READ_INTERVAL);
  
  if (shouldReadTimestamp) {
    // Resolve all queries (6 queries) to buffer
    encoder.resolveQuerySet(timestampQuerySet, 0, 6, timestampBuffer, 0);
    // Copy from timestamp buffer to staging buffer for readback
    encoder.copyBufferToBuffer(timestampBuffer, 0, timestampStagingBuffer, 0, 48);
    timestampReadbackPending = true;
    lastTimestampReadTime = currentTime;
    return true;
  }
  return false;
}

// Staging buffer for timestamp readback
let timestampStagingBuffer = null;
if (timestampBuffer) {
  timestampStagingBuffer = device.createBuffer({
    size: 48, // 6 u64 values
    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
  });
}

function initializeParticles() {
  // JS-side data
  const particleData = new Float32Array(numParticles * 4); // x, y, vx, vy
  for (let i = 0; i < numParticles; i++) {
    particleData[i * 4 + 0] = (Math.random() * 2 - 1) * 0.9;  // x
    particleData[i * 4 + 1] = (Math.random() * 2 - 1) * 0.9;  // y
    particleData[i * 4 + 2] = (Math.random() * 2 - 1) * 0.1;  // vx
    particleData[i * 4 + 3] = (Math.random() * 2 - 1) * 0.1;  // vy
  }

  // GPU buffers
  if (particleBuffer) {
    particleBuffer.destroy();
  }
  particleBuffer = device.createBuffer({
    size: particleData.byteLength,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(particleBuffer, 0, particleData);
  console.log('Wrote particle buffer to GPU');

  if (cellIndexBuffer) {
    cellIndexBuffer.destroy();
  }
  cellIndexBuffer = device.createBuffer({
    size: numParticles * 4, // one u32 per particle
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });
  
  // Neighbor indices buffer: flattened array where each particle has MAX_NEIGHBORS consecutive slots
  // Layout: [particle0_neighbor0, particle0_neighbor1, ..., particle0_neighborN-1, particle1_neighbor0, ...]
  if (neighborIndicesBuffer) {
    neighborIndicesBuffer.destroy();
  }
  neighborIndicesBuffer = device.createBuffer({
    size: numParticles * MAX_NEIGHBORS * 4, // MAX_NEIGHBORS u32s per particle
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });
  // Initialize to invalid indices (numParticles, which is out of bounds)
  const neighborInitData = new Uint32Array(numParticles * MAX_NEIGHBORS);
  neighborInitData.fill(numParticles); // Use numParticles as invalid marker (out of bounds)
  device.queue.writeBuffer(neighborIndicesBuffer, 0, neighborInitData);
  console.log('Created neighbor indices buffer');
  
  // Neighbor count buffer: one u32 per particle storing how many valid neighbors it has
  if (neighborCountBuffer) {
    neighborCountBuffer.destroy();
  }
  neighborCountBuffer = device.createBuffer({
    size: numParticles * 4, // one u32 per particle
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });
  // Initialize to zero
  device.queue.writeBuffer(neighborCountBuffer, 0, new Uint32Array(numParticles));
  console.log('Created neighbor count buffer');
  
  // Cell-to-particle mapping buffer: for each cell, store indices of particles in that cell
  // Estimate max particles per cell: numParticles / numCells * safety factor
  const MAX_PARTICLES_PER_CELL = Math.ceil((numParticles / numCells) * 3); // 3x safety factor
  if (cellParticleListsBuffer) {
    cellParticleListsBuffer.destroy();
  }
  cellParticleListsBuffer = device.createBuffer({
    size: numCells * MAX_PARTICLES_PER_CELL * 4, // u32 per particle index
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });
  // Initialize to invalid indices
  const cellListInitData = new Uint32Array(numCells * MAX_PARTICLES_PER_CELL);
  cellListInitData.fill(0xFFFFFFFF); // Invalid marker (JavaScript, not WGSL)
  device.queue.writeBuffer(cellParticleListsBuffer, 0, cellListInitData);
  console.log(`Created cell-to-particle mapping buffer (${MAX_PARTICLES_PER_CELL} particles per cell max)`);
  
  // Store MAX_PARTICLES_PER_CELL globally for shader compilation
  window.MAX_PARTICLES_PER_CELL = MAX_PARTICLES_PER_CELL;
  
  // Recreate bind groups with new buffers
  computeBindGroup = device.createBindGroup({
    layout: computePipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: particleBuffer } },
      { binding: 1, resource: { buffer: cellIndexBuffer } },
      { binding: 2, resource: { buffer: uniformBuffer } },
      { binding: 3, resource: { buffer: gridVelocityBuffer } },
      { binding: 4, resource: { buffer: energySumBuffer } },
      { binding: 5, resource: { buffer: particleCountBuffer } },
    ],
  });
  
  // Create render params uniform buffer (just for monochrome flag)
  const renderParamsData = new Float32Array(1);
  renderParamsData[0] = monochrome ? 1.0 : 0.0;
  renderParamsBuffer = device.createBuffer({
    size: renderParamsData.byteLength,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(renderParamsBuffer, 0, renderParamsData);
  
  renderBindGroup = device.createBindGroup({
    layout: renderPipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: particleBuffer } },
      { binding: 1, resource: { buffer: cellIndexBuffer } },
      { binding: 2, resource: { buffer: renderParamsBuffer } },
    ],
  });
  
  // Create build cell mapping bind group
  buildCellMappingBindGroup = device.createBindGroup({
    layout: buildCellMappingPipeline.getBindGroupLayout(0),
    entries: [
      { binding: 1, resource: { buffer: cellIndexBuffer } },
      { binding: 4, resource: { buffer: cellParticleListsBuffer } },
      { binding: 5, resource: { buffer: particleCountBuffer } },
    ],
  });
  
  // Create find neighbors bind group
  findNeighborsBindGroup = device.createBindGroup({
    layout: findNeighborsPipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: particleBuffer } },
      { binding: 1, resource: { buffer: cellIndexBuffer } },
      { binding: 2, resource: { buffer: neighborIndicesBuffer } },
      { binding: 3, resource: { buffer: neighborCountBuffer } },
      { binding: 4, resource: { buffer: cellParticleListsBuffer } },
      { binding: 5, resource: { buffer: particleCountBuffer } },
    ],
  });
  
  // Create flocking bind group
  flockingBindGroup = device.createBindGroup({
    layout: flockingPipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: particleBuffer } },
      { binding: 1, resource: { buffer: neighborIndicesBuffer } },
      { binding: 2, resource: { buffer: neighborCountBuffer } },
      { binding: 3, resource: { buffer: uniformBuffer } },
    ],
  });
}

// Grid configuration: cells per direction
const cellsPerDirection = 50;
const numCells = cellsPerDirection * cellsPerDirection;

// Calculate MAX_PARTICLES_PER_CELL at top level for shader compilation
// This will be updated in initializeParticles() if numParticles changes
window.MAX_PARTICLES_PER_CELL = Math.ceil((numParticles / numCells) * 3);
const gridVelocityData = new Float32Array(numCells * 2); // Initialize to zero
const gridVelocityBuffer = device.createBuffer({
  size: gridVelocityData.byteLength,
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
});
device.queue.writeBuffer(gridVelocityBuffer, 0, gridVelocityData);
console.log('Created grid velocity buffer');

// Particle count buffer: one u32 per cell
const particleCountBuffer = device.createBuffer({
  size: numCells * 4, // one u32 (4 bytes) per cell
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
});
// Initialize to zero
device.queue.writeBuffer(particleCountBuffer, 0, new Uint32Array(numCells));
console.log('Created particle count buffer');


let drag = 1.0;
let decay = 1.0;
let dt = 0.016;
let cohesion = 0.03;
let separationStrength = 0.05;
let separationDistance = 0.02;
let alignment = 0.009;
let monochrome = false;
let coupleToGrid = true; // Default to enabled

const uniformData = new Float32Array(32); // Increased to accommodate new parameters
uniformData[0] = dt;
uniformData[1] = drag;
uniformData[2] = decay;
uniformData[3] = cohesion;
uniformData[4] = separationStrength;
uniformData[5] = separationDistance;
uniformData[6] = alignment;
uniformData[7] = coupleToGrid ? 1.0 : 0.0; // Couple to grid flag (f32: 1.0 = true, 0.0 = false)

const uniformBuffer = device.createBuffer({
  size: uniformData.byteLength,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
});
device.queue.writeBuffer(uniformBuffer, 0, uniformData);
console.log('Wrote uniform buffer to GPU');

// Energy sum buffer (atomic u32)
const energySumBuffer = device.createBuffer({
  size: 4, // single u32
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
});

// Staging buffer to read back energy
const energyStagingBuffer = device.createBuffer({
  size: 4,
  usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
});

// Initialize energy buffer to zero
device.queue.writeBuffer(energySumBuffer, 0, new Uint32Array([0]));
console.log('Created energy sum buffer');

//
// === Compute Shader (WGSL) ===
//
const computeShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;
const CELL_SIZE = 2.0 / f32(CELLS_PER_DIRECTION);
const MAX_CELL_INDEX = ${cellsPerDirection - 1}u;

struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
};

@group(0) @binding(0)
var<storage, read_write> particles: array<Particle>;

@group(0) @binding(1)
var<storage, read_write> cellIndices: array<u32>;

@group(0) @binding(3)
var<storage, read_write> gridVelocities: array<vec2<f32>>;

@group(0) @binding(4)
var<storage, read_write> energySum: atomic<u32>;

@group(0) @binding(5)
var<storage, read_write> particleCounts: array<atomic<u32>>;

struct Params {
  dt: f32,
  drag: f32,
  decay: f32,
  cohesion: f32,
  separationStrength: f32,
  separationDistance: f32,
  alignment: f32,
  coupleToGrid: f32, // 1.0 = true, 0.0 = false
};

@group(0) @binding(2)
var<uniform> params: Params;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let i = id.x;
  if (i >= arrayLength(&particles)) { return; }

  var p = particles[i];

  // --- physics ---
  p.pos += p.vel * params.dt;

  // bounce
  if (abs(p.pos.x) > 1.0) { p.vel.x = -p.vel.x; }
  if (abs(p.pos.y) > 1.0) { p.vel.y = -p.vel.y; }

  // --- grid assignment ---
  let gx = clamp(floor((p.pos.x + 1.0) / CELL_SIZE), 0.0, f32(MAX_CELL_INDEX));
  let gy = clamp(floor((p.pos.y + 1.0) / CELL_SIZE), 0.0, f32(MAX_CELL_INDEX));
  let cellIndex = u32(gy * f32(CELLS_PER_DIRECTION) + gx);
  cellIndices[i] = cellIndex;

  // Count particle in this cell (atomic increment)
  atomicAdd(&particleCounts[cellIndex], 1u);

  // --- grid-particle interaction ---
  if (params.coupleToGrid > 0.5) {
    let gridVel = gridVelocities[cellIndex];
    let particleVelBefore = p.vel; // Store original particle velocity
    
    // grid-particle coupling constants 
    const GRID_TO_PARTICLE = 0.1;    // typical 0.1
    const PARTICLE_TO_GRID = 0.001;    // typical 0.001

    // Add grid velocity to particle velocity
    let gridVelMagnitude = length(gridVel);
    if (gridVelMagnitude > 0.0) {
      p.vel += normalize(gridVel) * (PARTICLE_TO_GRID * gridVelMagnitude);
    }
    
    // Accumulate particle velocity contribution to grid (will be normalized by count later)
    gridVelocities[cellIndex] = gridVel + particleVelBefore * GRID_TO_PARTICLE;
  }

  // Apply decay proportional to square of velocity
  let velSquared = dot(p.vel, p.vel);
  
  p.vel *= (1.0 - velSquared * params.drag); 
  p.vel *= params.decay;
  
  // Accumulate energy (velocity^2) atomically
  // Convert velSquared (0.0-1.0) to u32 in range 1-100
  let energyValue = u32(velSquared * 10000.0);  
  atomicAdd(&energySum, energyValue);
  
  particles[i] = p;
}

`;

const computeModule = device.createShaderModule({ code: computeShaderCode });
const computePipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: computeModule, entryPoint: 'main' },
});

//
// === Grid Decay Compute Shader (WGSL) ===
//
const gridDecayShaderCode = /* wgsl */`
@group(0) @binding(3)
var<storage, read_write> gridVelocities: array<vec2<f32>>;

struct Params {
  dt: f32,
  drag: f32,
  decay: f32,
};
@group(0) @binding(2)
var<uniform> params: Params;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let i = id.x;
  if (i >= arrayLength(&gridVelocities)) { return; }
  
  // Apply decay factor to grid velocity
  gridVelocities[i] *= params.decay;
}

`;

const gridDecayModule = device.createShaderModule({ code: gridDecayShaderCode });
const gridDecayPipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: gridDecayModule, entryPoint: 'main' },
});
const gridDecayBindGroup = device.createBindGroup({
  layout: gridDecayPipeline.getBindGroupLayout(0),
  entries: [
    { binding: 2, resource: { buffer: uniformBuffer } },
    { binding: 3, resource: { buffer: gridVelocityBuffer } },
  ],
});

//
// === Velocity Normalization Compute Shader (WGSL) ===
//
const normalizeVelocityShaderCode = /* wgsl */`
@group(0) @binding(0)
var<storage, read_write> gridVelocities: array<vec2<f32>>;

@group(0) @binding(1)
var<storage, read_write> particleCounts: array<atomic<u32>>;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let i = id.x;
  if (i >= arrayLength(&gridVelocities)) { return; }
  
  // Get particle count for this cell
  let count = f32(atomicLoad(&particleCounts[i]));
  
  // Normalize velocity by particle count (avoid division by zero)
  if (count > 0.0) {
    gridVelocities[i] = gridVelocities[i] / count;
  } else {
    gridVelocities[i] = vec2<f32>(0.0, 0.0);
  }
}
`;

const normalizeVelocityModule = device.createShaderModule({ code: normalizeVelocityShaderCode });
const normalizeVelocityPipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: normalizeVelocityModule, entryPoint: 'main' },
});

const normalizeVelocityBindGroup = device.createBindGroup({
  layout: normalizeVelocityPipeline.getBindGroupLayout(0),
  entries: [
    { binding: 0, resource: { buffer: gridVelocityBuffer } },
    { binding: 1, resource: { buffer: particleCountBuffer } },
  ],
});

//
// === Build Cell-to-Particle Mapping Compute Shader (WGSL) ===
// Builds a list of particle indices for each cell for fast neighbor lookup
//
const buildCellMappingShaderCode = /* wgsl */`
const MAX_PARTICLES_PER_CELL = ${window.MAX_PARTICLES_PER_CELL}u;

@group(0) @binding(1)
var<storage, read> cellIndices: array<u32>;

@group(0) @binding(4)
var<storage, read_write> cellParticleLists: array<u32>; // Flattened: numCells * MAX_PARTICLES_PER_CELL

@group(0) @binding(5)
var<storage, read_write> particleCounts: array<atomic<u32>>;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let particleIdx = id.x;
  if (particleIdx >= arrayLength(&cellIndices)) { return; }
  
  let cellIdx = cellIndices[particleIdx];
  
  // Get the current count for this cell (atomically)
  let slot = atomicAdd(&particleCounts[cellIdx], 1u);
  
  // Check if we have room in this cell's list
  if (slot < MAX_PARTICLES_PER_CELL) {
    let listBase = cellIdx * MAX_PARTICLES_PER_CELL;
    cellParticleLists[listBase + slot] = particleIdx;
  }
  // If slot >= MAX_PARTICLES_PER_CELL, we've exceeded capacity (shouldn't happen with good estimate)
}
`;

const buildCellMappingModule = device.createShaderModule({ code: buildCellMappingShaderCode });
const buildCellMappingPipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: buildCellMappingModule, entryPoint: 'main' },
});

let buildCellMappingBindGroup; // Will be created in initializeParticles()

//
// === Find Neighbors Compute Shader (WGSL) ===
// Finds the N nearest neighbors for each particle using the grid for spatial acceleration
//
const findNeighborsShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;
const MAX_NEIGHBORS = ${MAX_NEIGHBORS}u;
const MAX_PARTICLES_PER_CELL = ${window.MAX_PARTICLES_PER_CELL}u;

struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
};

@group(0) @binding(0)
var<storage, read> particles: array<Particle>;

@group(0) @binding(1)
var<storage, read> cellIndices: array<u32>;

@group(0) @binding(2)
var<storage, read_write> neighborIndices: array<u32>;

@group(0) @binding(3)
var<storage, read_write> neighborCounts: array<u32>;

@group(0) @binding(4)
var<storage, read> cellParticleLists: array<u32>; // Flattened: numCells * MAX_PARTICLES_PER_CELL

@group(0) @binding(5)
var<storage, read> particleCounts: array<u32>; // Count of particles per cell

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let particleIdx = id.x;
  if (particleIdx >= arrayLength(&particles)) { return; }
  
  let p = particles[particleIdx];
  let myCell = cellIndices[particleIdx];
  
  // Calculate grid coordinates for this particle's cell
  let myGx = myCell % CELLS_PER_DIRECTION;
  let myGy = myCell / CELLS_PER_DIRECTION;
  
  // Array to store candidate neighbors with their distances
  var nearestIndices: array<u32, MAX_NEIGHBORS>;
  var nearestDistances: array<f32, MAX_NEIGHBORS>;
  var numFound: u32 = 0u;
  
  // Initialize distances to a large value
  for (var i = 0u; i < MAX_NEIGHBORS; i++) {
    nearestDistances[i] = 1000000.0; // Large initial distance
    nearestIndices[i] = 0xFFFFFFFFu; // Invalid index marker
  }
  
  // Check particles in the same cell and 8 adjacent cells (3x3 grid)
  for (var dy = 0u; dy < 3u; dy++) {
    for (var dx = 0u; dx < 3u; dx++) {
      // Convert 0-2 range to -1 to +1 range
      var offsetX = i32(dx) - 1;
      var offsetY = i32(dy) - 1;
      
      var checkGx = i32(myGx) + offsetX;
      var checkGy = i32(myGy) + offsetY;
      
      // Skip if out of bounds
      if (checkGx < 0 || checkGx >= i32(CELLS_PER_DIRECTION)) { continue; }
      if (checkGy < 0 || checkGy >= i32(CELLS_PER_DIRECTION)) { continue; }
      
      let checkCell = u32(checkGy) * CELLS_PER_DIRECTION + u32(checkGx);
      
      // Get the list of particles in this cell from the pre-built mapping
      let cellParticleCount = particleCounts[checkCell];
      let listBase = checkCell * MAX_PARTICLES_PER_CELL;
      
      // Iterate only through particles in this cell (much faster!)
      for (var slot = 0u; slot < cellParticleCount && slot < MAX_PARTICLES_PER_CELL; slot++) {
        let candidateIdx = cellParticleLists[listBase + slot];
        if (candidateIdx == particleIdx) { continue; } // Skip self
        if (candidateIdx >= arrayLength(&particles)) { continue; } // Skip invalid
        
        let candidate = particles[candidateIdx];
        let distSq = dot(candidate.pos - p.pos, candidate.pos - p.pos);
        
        // Insert this candidate if it's closer than our current farthest neighbor
        // Find the worst (farthest) neighbor in our list
        var worstIdx = 0u;
        var worstDist = nearestDistances[0u];
        for (var k = 1u; k < MAX_NEIGHBORS; k++) {
          if (nearestDistances[k] > worstDist) {
            worstDist = nearestDistances[k];
            worstIdx = k;
          }
        }
        
        // If this candidate is closer than our worst, replace it
        if (distSq < worstDist) {
          nearestDistances[worstIdx] = distSq;
          nearestIndices[worstIdx] = candidateIdx;
          if (numFound < MAX_NEIGHBORS) {
            numFound++;
          }
        }
      }
    }
  }
  
  // Write results to buffers
  let baseIndex = particleIdx * MAX_NEIGHBORS;
  for (var i = 0u; i < MAX_NEIGHBORS; i++) {
    if (i < numFound) {
      neighborIndices[baseIndex + i] = nearestIndices[i];
    } else {
      neighborIndices[baseIndex + i] = 0xFFFFFFFFu; // Invalid marker
    }
  }
  neighborCounts[particleIdx] = numFound;
}
`;

const findNeighborsModule = device.createShaderModule({ code: findNeighborsShaderCode });
const findNeighborsPipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: findNeighborsModule, entryPoint: 'main' },
});

let findNeighborsBindGroup; // Will be created in initializeParticles()

//
// === Flocking Compute Shader (WGSL) ===
// Applies cohesion, separation, and alignment forces based on neighbors
//
const flockingShaderCode = /* wgsl */`
const MAX_NEIGHBORS = ${MAX_NEIGHBORS}u;

struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
};

@group(0) @binding(0)
var<storage, read_write> particles: array<Particle>;

@group(0) @binding(1)
var<storage, read> neighborIndices: array<u32>; // Flattened: numParticles * MAX_NEIGHBORS

@group(0) @binding(2)
var<storage, read> neighborCounts: array<u32>; // One per particle

struct Params {
  dt: f32,
  drag: f32,
  decay: f32,
  cohesion: f32,
  separationStrength: f32,
  separationDistance: f32,
  alignment: f32,
};

@group(0) @binding(3)
var<uniform> params: Params;

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let particleIdx = id.x;
  if (particleIdx >= arrayLength(&particles)) { return; }
  
  var p = particles[particleIdx];
  let numNeighbors = neighborCounts[particleIdx];
  
  if (numNeighbors == 0u) { return; } // No neighbors, no flocking
  
  let baseIndex = particleIdx * MAX_NEIGHBORS;
  
  // Accumulators for flocking forces
  var cohesionForce = vec2<f32>(0.0, 0.0); // Move toward average position
  var separationForce = vec2<f32>(0.0, 0.0); // Move away from close neighbors
  var alignmentForce = vec2<f32>(0.0, 0.0); // Match average velocity
  var validNeighbors = 0u;
  
  // Iterate through neighbors
  for (var n = 0u; n < numNeighbors && n < MAX_NEIGHBORS; n++) {
    let neighborIdx = neighborIndices[baseIndex + n];
    if (neighborIdx >= arrayLength(&particles)) { continue; } // Skip invalid
    
    let neighbor = particles[neighborIdx];
    let diff = neighbor.pos - p.pos;
    let distSq = dot(diff, diff);
    let dist = sqrt(distSq);
    
    if (dist > 0.001) { // Avoid division by zero
      let diffNorm = diff / dist;
      
      // Cohesion: move toward neighbor's position
      cohesionForce += diff * params.cohesion;
      
      // Separation: move away from neighbors that are too close
      if (dist < params.separationDistance) {
        separationForce -= diffNorm * params.separationStrength;  // / (dist + 0.001);
      }
      
      // Alignment: match neighbor's velocity
      alignmentForce += neighbor.vel * params.alignment;
      
      validNeighbors++;
    }
  }
  
  if (validNeighbors > 0u) {
    // Normalize forces by number of neighbors
    let invCount = 1.0 / f32(validNeighbors);
    cohesionForce *= invCount;
    separationForce *= invCount;
    alignmentForce *= invCount;
    
    // Apply forces to velocity
    p.vel += cohesionForce + separationForce + alignmentForce;
  }
  
  particles[particleIdx] = p;
}
`;

const flockingModule = device.createShaderModule({ code: flockingShaderCode });
const flockingPipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: flockingModule, entryPoint: 'main' },
});

let flockingBindGroup; // Will be created in initializeParticles()

// computeBindGroup will be created in initializeParticles()

//
// === Render Shader (WGSL) ===
//
const renderShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;

struct VSOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) color: vec4<f32>,
};

@group(0) @binding(0)
var<storage, read> particles: array<vec4<f32>>; // pos+vel packed

@group(0) @binding(1)
var<storage, read> cellIndices: array<u32>;

struct RenderParams {
  monochrome: f32, // 1.0 = true, 0.0 = false
};

@group(0) @binding(2)
var<uniform> renderParams: RenderParams;

@vertex
fn vs_main(@builtin(vertex_index) vid: u32) -> VSOut {
  var out: VSOut;
  let p = particles[vid];
  out.pos = vec4<f32>(p.xy, 0.0, 1.0);

  // Use white color if monochrome is enabled, otherwise use velocity-based coloring
  if (renderParams.monochrome > 0.5) {
    out.color = vec4<f32>(1.0, 1.0, 1.0, 1.0); // White
  } else {
    let cell = cellIndices[vid];
    let gx = cell % CELLS_PER_DIRECTION;
    let gy = cell / CELLS_PER_DIRECTION;
    // Create color based on velocity
    let v = p.zw;
    let velSquared = dot(v, v);
    let r =  clamp(0.5 + v.x * 100.0, 0.0, 1.0);   // f32(gx) / 9.0;
    let g =  clamp(0.5 + v.y * 100.0, 0.0, 1.0);   //f32(gy) / 9.0;
    let b =  clamp(0.5 + (v.x + v.y) * 100.0, 0.0, 1.0);   // fract(f32(cell) / 7.0); // Add some variation
    out.color = vec4<f32>(r, g, b, 1.0);
  }
  return out;
}

@fragment
fn fs_main(in: VSOut) -> @location(0) vec4<f32> {
  return in.color;
}

`;

const renderModule = device.createShaderModule({ code: renderShaderCode });
const renderPipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: {
    module: renderModule,
    entryPoint: 'vs_main',
  },
  fragment: {
    module: renderModule,
    entryPoint: 'fs_main',
    targets: [{ format }],
  },
  primitive: { topology: 'point-list' },
});

//
// === Grid Rendering Shader (WGSL) ===
//
const gridShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;
const CELL_SIZE = 2.0 / f32(CELLS_PER_DIRECTION);

struct VSOut {
  @builtin(position) pos: vec4<f32>,
};

@vertex
fn vs_main(@builtin(vertex_index) vid: u32) -> VSOut {
  var out: VSOut;
  
  // Generate grid lines: vertical and horizontal lines
  // Total vertices: 2 * (cellsPerDirection + 1) vertical lines * 2 vertices + 
  //                 2 * (cellsPerDirection + 1) horizontal lines * 2 vertices
  // = 4 * (cellsPerDirection + 1) vertices
  
  let totalVerticalVertices = 2u * (CELLS_PER_DIRECTION + 1u);
  let vertexInLine = vid % 2u;
  
  if (vid < totalVerticalVertices) {
    // Vertical lines
    let lineIndex = vid / 2u;
    let x = -1.0 + f32(lineIndex) * CELL_SIZE;
    var y: f32;
    if (vertexInLine == 0u) {
      y = -1.0;
    } else {
      y = 1.0;
    }
    out.pos = vec4<f32>(x, y, 0.0, 1.0);
  } else {
    // Horizontal lines
    let horizontalVid = vid - totalVerticalVertices;
    let lineIndex = horizontalVid / 2u;
    var x: f32;
    if (vertexInLine == 0u) {
      x = -1.0;
    } else {
      x = 1.0;
    }
    let y = -1.0 + f32(lineIndex) * CELL_SIZE;
    out.pos = vec4<f32>(x, y, 0.0, 1.0);
  }
  
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
  // Gray color for grid lines
  return vec4<f32>(0.3, 0.3, 0.3, 0.5);
}
`;

const gridModule = device.createShaderModule({ code: gridShaderCode });
const gridPipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: {
    module: gridModule,
    entryPoint: 'vs_main',
  },
  fragment: {
    module: gridModule,
    entryPoint: 'fs_main',
    targets: [{ format }],
  },
  primitive: { topology: 'line-list' },
});

//
// === Velocity Vector Rendering Shader (WGSL) ===
//
const velocityVectorShaderCode = /* wgsl */`
const CELLS_PER_DIRECTION = ${cellsPerDirection}u;
const CELL_SIZE = 2.0 / f32(CELLS_PER_DIRECTION);
const HALF_CELL = CELL_SIZE * 0.5;
const VECTOR_SCALE = 100.0; // Scale factor for velocity vectors

struct VSOut {
  @builtin(position) pos: vec4<f32>,
};

@group(0) @binding(0)
var<storage, read> gridVelocities: array<vec2<f32>>;

@vertex
fn vs_main(@builtin(vertex_index) vid: u32,
           @builtin(instance_index) iid: u32) -> VSOut {
  var out: VSOut;
  
  // Get cell center position
  let gx = iid % CELLS_PER_DIRECTION;
  let gy = iid / CELLS_PER_DIRECTION;
  let cellCenterX = -1.0 + f32(gx) * CELL_SIZE + HALF_CELL;
  let cellCenterY = -1.0 + f32(gy) * CELL_SIZE + HALF_CELL;
  
  // Get grid velocity for this cell
  let vel = gridVelocities[iid];
  let velMagnitude = length(vel);
  
  // Draw line from center to center + velocity (scaled)
  if (vid == 0u) {
    // Start point: cell center
    out.pos = vec4<f32>(cellCenterX, cellCenterY, 0.0, 1.0);
  } else {
    // End point: center + velocity * scale
    let endX = cellCenterX + vel.x * VECTOR_SCALE;
    let endY = cellCenterY + vel.y * VECTOR_SCALE;
    out.pos = vec4<f32>(endX, endY, 0.0, 1.0);
  }
  
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
  // Yellow color for velocity vectors
  return vec4<f32>(1.0, 1.0, 0.0, 0.8);
}
`;

const velocityVectorModule = device.createShaderModule({ code: velocityVectorShaderCode });
const velocityVectorPipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: {
    module: velocityVectorModule,
    entryPoint: 'vs_main',
  },
  fragment: {
    module: velocityVectorModule,
    entryPoint: 'fs_main',
    targets: [{ format }],
  },
  primitive: { topology: 'line-list' },
});

// Create bind group for velocity vectors
const velocityVectorBindGroup = device.createBindGroup({
  layout: velocityVectorPipeline.getBindGroupLayout(0),
  entries: [
    { binding: 0, resource: { buffer: gridVelocityBuffer } },
  ],
});

// Track particle visibility
let showParticles = true;
const showParticlesCheckbox = document.getElementById('show-particles');
showParticlesCheckbox.addEventListener('change', (e) => {
  showParticles = e.target.checked;
});

// Track grid visibility
let showGrid = false;
const showGridCheckbox = document.getElementById('show-grid');
showGridCheckbox.addEventListener('change', (e) => {
  showGrid = e.target.checked;
});

// Track flocking state
let doFlocking = true; // Default to enabled
const doFlockingCheckbox = document.getElementById('do-flocking');
doFlockingCheckbox.addEventListener('change', (e) => {
  doFlocking = e.target.checked;
});

// Track monochrome state
const monochromeCheckbox = document.getElementById('monochrome');
monochromeCheckbox.addEventListener('change', (e) => {
  monochrome = e.target.checked;
  // Update render params buffer
  const renderParamsData = new Float32Array(1);
  renderParamsData[0] = monochrome ? 1.0 : 0.0;
  device.queue.writeBuffer(renderParamsBuffer, 0, renderParamsData);
});

// Track grid coupling state
const coupleToGridCheckbox = document.getElementById('couple-to-grid');
coupleToGridCheckbox.addEventListener('change', (e) => {
  coupleToGrid = e.target.checked;
  // Update uniform buffer
  uniformData[7] = coupleToGrid ? 1.0 : 0.0;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
});

// Track simulation running state
let simulationRunning = true;
const startStopBtn = document.getElementById('start-stop-btn');
startStopBtn.addEventListener('click', () => {
  simulationRunning = !simulationRunning;
  startStopBtn.textContent = simulationRunning ? 'Stop' : 'Start';
});

// Initialize particles (after pipelines are created)
initializeParticles();

// Control panel setup
const numParticlesInput = document.getElementById('num-particles');
numParticlesInput.value = numParticles; // Initialize input from JavaScript variable
const dragInput = document.getElementById('drag');
dragInput.value = drag; // Initialize input from JavaScript variable

const decayInput = document.getElementById('decay');
decayInput.value = decay;

const cohesionInput = document.getElementById('cohesion');
cohesionInput.value = cohesion;

const separationStrengthInput = document.getElementById('separation-strength');
separationStrengthInput.value = separationStrength;

const separationDistanceInput = document.getElementById('separation-distance');
separationDistanceInput.value = separationDistance;

const alignmentInput = document.getElementById('alignment');
alignmentInput.value = alignment;

function updatedrag(value) {
  drag = parseFloat(value);
  dragInput.value = drag;
  
  // Update uniform buffer
  uniformData[1] = drag;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
  console.log("Updated drag to ", drag);
}

dragInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const val = parseFloat(e.target.value);
    updatedrag(isNaN(val) ? 0.1 : val);
  }
});

function updateDecay(value) {
  decay = parseFloat(value);
  decayInput.value = decay;
  
  // Update uniform buffer
  uniformData[2] = decay;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
  console.log("Updated decay to ", decay);
}

function updateCohesion(value) {
  cohesion = parseFloat(value);
  cohesionInput.value = cohesion;
  
  // Update uniform buffer
  uniformData[3] = cohesion;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
  console.log("Updated cohesion to ", cohesion);
}

function updateSeparationStrength(value) {
  separationStrength = parseFloat(value);
  separationStrengthInput.value = separationStrength;
  
  // Update uniform buffer
  uniformData[4] = separationStrength;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
  console.log("Updated separation strength to ", separationStrength);
}

function updateSeparationDistance(value) {
  separationDistance = parseFloat(value);
  separationDistanceInput.value = separationDistance;
  
  // Update uniform buffer
  uniformData[5] = separationDistance;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
  console.log("Updated separation distance to ", separationDistance);
}

function updateAlignment(value) {
  alignment = parseFloat(value);
  alignmentInput.value = alignment;
  
  // Update uniform buffer
  uniformData[6] = alignment;
  device.queue.writeBuffer(uniformBuffer, 0, uniformData);
  console.log("Updated alignment to ", alignment);
}

cohesionInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const val = parseFloat(e.target.value);
    updateCohesion(isNaN(val) ? 0.03 : val);
  }
});

separationStrengthInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const val = parseFloat(e.target.value);
    updateSeparationStrength(isNaN(val) ? 0.05 : val);
  }
});

separationDistanceInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const val = parseFloat(e.target.value);
    updateSeparationDistance(isNaN(val) ? 0.02 : val);
  }
});

alignmentInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const val = parseFloat(e.target.value);
    updateAlignment(isNaN(val) ? 0.009 : val);
  }
});

function restartSimulation() {
  // Stop current animation
  if (frameId !== null) {
    cancelAnimationFrame(frameId);
    frameId = null;
  }
  
  // Reset grid velocities
  const gridVelocityData = new Float32Array(numCells * 2);
  device.queue.writeBuffer(gridVelocityBuffer, 0, gridVelocityData);
  
  // Reinitialize particles with new count
  initializeParticles();
  
  // Restart animation
  frame();
}

numParticlesInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    const newCount = Math.max(1000, Math.min(10000000, parseInt(e.target.value) || 1000000));
    if (newCount !== numParticles) {
      numParticles = newCount;
      numParticlesInput.value = numParticles;
      restartSimulation();
    }
  }
});

//
// === Frame loop ===
//
let lastTime = performance.now();
let frameCount = 0;
let fps = 0;
const fpsCounter = document.getElementById('fps-counter');
const energyCounter = document.getElementById('energy-counter');
let energyReadbackPending = false;
let lastEnergyReadTime = 0;
let neighborUpdateCounter = 0;
const NEIGHBOR_UPDATE_INTERVAL = 10; // Update neighbors every 10 frames

function frame() {
  const currentTime = performance.now();
  const deltaTime = currentTime - lastTime;
  frameCount++;
  
  // Update FPS every second
  if (deltaTime >= 1000) {
    fps = Math.round((frameCount * 1000) / deltaTime);
    fpsCounter.textContent = `FPS: ${fps}`;
    frameCount = 0;
    lastTime = currentTime;
  }
  
  const encoder = device.createCommandEncoder();
  let shouldReadEnergy = false;
  let shouldReadTimestamp = false;

  // Only run compute passes if simulation is running
  if (simulationRunning) {
    // Reset energy buffer to zero before compute
    device.queue.writeBuffer(energySumBuffer, 0, new Uint32Array([0]));
    
    // Reset particle count buffer to zero before compute
    device.queue.writeBuffer(particleCountBuffer, 0, new Uint32Array(numCells));

    // 0️⃣ Grid decay compute pass (runs once per frame)
    {
      const pass = encoder.beginComputePass();
      pass.setPipeline(gridDecayPipeline);
      pass.setBindGroup(0, gridDecayBindGroup);
      pass.dispatchWorkgroups(Math.ceil(numCells / 64)); // numCells workgroups
      pass.end();
    }

    // 1️⃣ Particle compute pass (with GPU timing)
    {
      const pass = createTimedComputePass(encoder, 0); // Use query indices 0-1
      pass.setPipeline(computePipeline);
      pass.setBindGroup(0, computeBindGroup);
      pass.dispatchWorkgroups(Math.ceil(numParticles / 64));
      pass.end();
    }

    // 1.5️⃣ Normalize grid velocities by particle count
    {
      const pass = encoder.beginComputePass();
      pass.setPipeline(normalizeVelocityPipeline);
      pass.setBindGroup(0, normalizeVelocityBindGroup);
      pass.dispatchWorkgroups(Math.ceil(numCells / 64));
      pass.end();
    }

    // 1.75️⃣ Find neighbors compute pass (runs periodically, every NEIGHBOR_UPDATE_INTERVAL frames)
    // Runs after particle compute so it uses fresh cell indices
    neighborUpdateCounter++;
    if (neighborUpdateCounter >= NEIGHBOR_UPDATE_INTERVAL) {
      neighborUpdateCounter = 0;
      
      // Reset particleCounts for building cell mapping (we'll reuse it)
      device.queue.writeBuffer(particleCountBuffer, 0, new Uint32Array(numCells));
      
      // Reset cellParticleLists to invalid indices
      const cellListResetData = new Uint32Array(numCells * window.MAX_PARTICLES_PER_CELL);
      cellListResetData.fill(0xFFFFFFFF); // Invalid marker (JavaScript, not WGSL)
      device.queue.writeBuffer(cellParticleListsBuffer, 0, cellListResetData);
      
      // Build cell-to-particle mapping (must run before findNeighbors)
      {
        const pass = encoder.beginComputePass();
        pass.setPipeline(buildCellMappingPipeline);
        pass.setBindGroup(0, buildCellMappingBindGroup);
        pass.dispatchWorkgroups(Math.ceil(numParticles / 64));
        pass.end();
      }
      
      // Now find neighbors using the optimized cell mapping
      {
        const pass = createTimedComputePass(encoder, 2); // Use query indices 2-3 for timing
        pass.setPipeline(findNeighborsPipeline);
        pass.setBindGroup(0, findNeighborsBindGroup);
        pass.dispatchWorkgroups(Math.ceil(numParticles / 64));
        pass.end();
      }
    }

    // 1.8️⃣ Flocking compute pass (applies cohesion, separation, alignment)
    if (doFlocking) {
      const pass = createTimedComputePass(encoder, 4); // Use query indices 4-5 for timing
      pass.setPipeline(flockingPipeline);
      pass.setBindGroup(0, flockingBindGroup);
      pass.dispatchWorkgroups(Math.ceil(numParticles / 64));
      pass.end();
    }

    // Copy energy from GPU to staging buffer for readback (only when ready to read)
    shouldReadEnergy = !energyReadbackPending && (currentTime - lastEnergyReadTime >= 1000);
    if (shouldReadEnergy) {
      encoder.copyBufferToBuffer(energySumBuffer, 0, energyStagingBuffer, 0, 4);
      energyReadbackPending = true;
      lastEnergyReadTime = currentTime;
    }
    
    // Resolve timestamp queries if needed
    shouldReadTimestamp = resolveTimestamps(encoder, currentTime);
  }

  // 2️⃣ Render pass
  const textureView = context.getCurrentTexture().createView();
  const renderPass = encoder.beginRenderPass({
    colorAttachments: [{
      view: textureView,
      clearValue: { r: 0, g: 0, b: 0, a: 1 },
      loadOp: 'clear',
      storeOp: 'store',
    }],
  });
  
  // Render particles if enabled
  if (showParticles) {
    renderPass.setPipeline(renderPipeline);
    renderPass.setBindGroup(0, renderBindGroup);
    renderPass.draw(numParticles);
  }
  
  // Render grid lines and velocity vectors if enabled
  if (showGrid) {
    renderPass.setPipeline(gridPipeline);
    // Draw grid lines: 2 * (cellsPerDirection + 1) lines, each with 2 vertices
    const gridVertices = 2 * 2 * (cellsPerDirection + 1);
    renderPass.draw(gridVertices);
    
    // Render velocity vectors
    renderPass.setPipeline(velocityVectorPipeline);
    renderPass.setBindGroup(0, velocityVectorBindGroup);
    // Draw one line (2 vertices) per cell, using instancing
    renderPass.draw(2, numCells, 0, 0);
  }
  
  renderPass.end();

  device.queue.submit([encoder.finish()]);
  
  // Read back timestamps asynchronously after submit
  if (shouldReadTimestamp && timestampStagingBuffer) {
    timestampStagingBuffer.mapAsync(GPUMapMode.READ).then(() => {
      const timestampArray = new BigUint64Array(timestampStagingBuffer.getMappedRange());
      
      // Get timestamp period (nanoseconds per tick)
      // Try different APIs as browser support varies
      let period = 1.0; // Default: 1 nanosecond per tick
      if (typeof device.queue.getTimestampPeriod === 'function') {
        period = device.queue.getTimestampPeriod();
      } else if (typeof device.getTimestampPeriod === 'function') {
        period = device.getTimestampPeriod();
      }
      // If period is not available, assume 1 nanosecond per tick (common default)
      
      // Calculate particle compute duration (queries 0-1)
      const particleStartTime = Number(timestampArray[0]);
      const particleEndTime = Number(timestampArray[1]);
      const particleDurationMs = (particleEndTime - particleStartTime) * period / 1_000_000;
      
      // Calculate findNeighbors duration (queries 2-3) if available
      let timingText = `Particle: ${particleDurationMs.toFixed(3)} ms`;
      if (timestampArray.length >= 4 && timestampArray[2] > 0 && timestampArray[3] > 0) {
        const findNeighborsStartTime = Number(timestampArray[2]);
        const findNeighborsEndTime = Number(timestampArray[3]);
        const findNeighborsDurationMs = (findNeighborsEndTime - findNeighborsStartTime) * period / 1_000_000;
        timingText += `<br>findNeighbors: ${findNeighborsDurationMs.toFixed(3)} ms`;
      }
      
      // Calculate flocking duration (queries 4-5) if available
      if (timestampArray.length >= 6 && timestampArray[4] > 0 && timestampArray[5] > 0) {
        const flockingStartTime = Number(timestampArray[4]);
        const flockingEndTime = Number(timestampArray[5]);
        const flockingDurationMs = (flockingEndTime - flockingStartTime) * period / 1_000_000;
        timingText += `<br>Flocking: ${flockingDurationMs.toFixed(3)} ms`;
      }
      
      timestampCounter.innerHTML = timingText;
      timestampStagingBuffer.unmap();
      timestampReadbackPending = false;
    }).catch(err => {
      console.error('Error reading timestamps:', err);
      timestampReadbackPending = false;
    });
  }
  
  // Read back energy asynchronously after submit (only once per second to avoid performance hit)
  if (shouldReadEnergy) {
    // Wait for the copy to complete before mapping
    energyStagingBuffer.mapAsync(GPUMapMode.READ).then(() => {
      const energyArray = new Uint32Array(energyStagingBuffer.getMappedRange());
      const energySum = energyArray[0];
      // Energy is stored as velSquared * 10000.0, so normalize by dividing by 10000.0 and numParticles
      const normalizedEnergy = energySum / (10000.0 * numParticles);
      energyCounter.textContent = `Energy: ${normalizedEnergy.toFixed(6)}`;
      energyStagingBuffer.unmap();
      energyReadbackPending = false;
    }).catch(err => {
      console.error('Error reading energy:', err);
      energyReadbackPending = false;
    });
  }
  
  frameId = requestAnimationFrame(frame);
}

frame();
</script>
</body>
</html>