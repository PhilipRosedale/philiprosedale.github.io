<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Run Tracker</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèÉ‚Äç‚ôÇÔ∏è</text></svg>" />
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
      padding: 1em; 
      background: #f7f7f7; 
      max-width: 600px;
      margin: 0 auto;
    }
    h1 { 
      font-size: 2.5em; 
      text-align: center;
      margin-bottom: 0.5em;
    }
    .unit-toggle {
      text-align: center;
      margin-top: 1em;
      padding: 0.5em;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 34px;
      margin: 0 1em;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 26px;
      width: 26px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #4CAF50;
    }
    input:checked + .slider:before {
      transform: translateX(26px);
    }
    .unit-label {
      font-size: 1.2em;
      font-weight: 600;
      color: #333;
    }
    #metrics { 
      background: white;
      padding: 0.75em;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      margin-bottom: 0.75em;
    }
    .metric {
      font-size: 1.8em; 
      margin: 0.5em 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.25em 0;
      border-bottom: 1px solid #eee;
    }
    .metric:last-child {
      border-bottom: none;
    }
    .metric-label {
      font-weight: 600;
      color: #333;
    }
    .metric-value {
      font-weight: 700;
      color: #4CAF50;
    }
    .button-group {
      display: flex;
      gap: 1em;
      justify-content: center;
    }
    button { 
      padding: 1em 2em; 
      font-size: 1.2em;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s ease;
    }
    .start-btn {
      background-color: #4CAF50;
      color: white;
    }
    .start-btn:hover {
      background-color: #45a049;
      transform: translateY(-2px);
    }
    .pause-btn {
      background-color: #ff9800;
      color: white;
    }
    .pause-btn:hover {
      background-color: #f57c00;
      transform: translateY(-2px);
    }
    .resume-btn {
      background-color: #2196F3;
      color: white;
    }
    .resume-btn:hover {
      background-color: #1976D2;
      transform: translateY(-2px);
    }
    .stop-btn {
      background-color: #f44336;
      color: white;
    }
    .stop-btn:hover {
      background-color: #da190b;
      transform: translateY(-2px);
    }
    .stop-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    .login-section {
      margin-top: 2em;
      padding: 1em;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    .user-info {
      display: none;
      color: #4CAF50;
      font-weight: 600;
    }
    .login-button {
      background-color: #4285f4;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    .login-button:hover {
      background-color: #357ae8;
    }
    .login-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
      opacity: 0.6;
    }
    .logout-button {
      background-color: #dc3545;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      margin-left: 10px;
    }
    .logout-button:hover {
      background-color: #c82333;
    }
    .debug-section {
      margin-top: 1em;
      padding: 0.5em;
      background: #f8f9fa;
      border-radius: 4px;
      border: 1px solid #dee2e6;
      font-family: monospace;
      font-size: 12px;
      color: #6c757d;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>üèÉ‚Äç‚ôÇÔ∏è Run Tracker</h1>
  
  <div id="metrics">
    <div class="metric">
      <span class="metric-label">Distance</span>
      <span class="metric-value" id="distance">0.00 mi</span>
    </div>
    <div class="metric">
      <span class="metric-label">Time</span>
      <span class="metric-value" id="time">00:00:00</span>
    </div>
    <div class="metric">
      <span class="metric-label">Pace</span>
      <span class="metric-value" id="pace">--:-- /mi</span>
    </div>
    <div class="metric">
      <span class="metric-label">Current Pace</span>
      <span class="metric-value" id="currentPace">--:-- /mi</span>
    </div>
  </div>
  <div class="button-group">
    <button id="startBtn" class="start-btn" onclick="startTracking()">Start</button>
    <button id="pauseBtn" class="pause-btn" onclick="pauseTracking()" style="display: none;">Pause</button>
    <button id="resumeBtn" class="resume-btn" onclick="resumeTracking()" style="display: none;">Resume</button>
    <button id="stopBtn" class="stop-btn" onclick="stopTracking()" style="display: none;">Stop</button>
  </div>
  
  <div class="unit-toggle">
    <span class="unit-label">Kilometers</span>
    <label class="toggle-switch">
      <input type="checkbox" id="unitToggle" onchange="toggleUnit()" checked>
      <span class="slider"></span>
    </label>
    <span class="unit-label">Miles</span>
  </div>

  <div class="login-section">
    <div id="loginButton">
      <button class="login-button" onclick="signIn()">Login with Google</button>
    </div>
    <div id="userInfo" class="user-info">
      <span>Logged in as: </span>
      <span id="userEmail"></span>
      <button class="logout-button" onclick="signOut()">Logout</button>
    </div>
  </div>

  <div class="debug-section">
    <span id="debugInfo">0 GPS reads, 0 feet</span>
    <span style="margin-left: 1em;">v1.7.0</span>
    <br>
    <label style="margin-top: 0.5em; display: inline-block;">
      <input type="checkbox" id="kalmanDebugToggle" onchange="toggleKalmanFilter()" checked>
      Enable Kalman Filter
    </label>
  </div>

  <script>
    // Google Sign-In configuration and functions
    let gapi;
    
    // Initialize Google Sign-In when the page loads
    window.onload = function() {
      // Check if Google Sign-In is available
      if (typeof google === 'undefined' || !google.accounts) {
        console.warn('Google Sign-In not available. This may be due to CORS restrictions or network issues.');
        document.getElementById('loginButton').innerHTML = '<button class="login-button" disabled>Google Sign-In Unavailable</button>';
        return;
      }

      try {
        google.accounts.id.initialize({
          // TODO: Replace with your actual Google Cloud Console OAuth 2.0 Client ID
          // Make sure to add http://localhost:8000 to authorized origins in Google Cloud Console
          client_id: '750994363443-t24js1sl18mn0032u2t7l6mkmsppfvtc.apps.googleusercontent.com',
          callback: handleCredentialResponse,
          auto_select: false,
          cancel_on_tap_outside: true
        });
        
        // Check if user is already signed in
        checkSignInStatus();
      } catch (error) {
        console.error('Error initializing Google Sign-In:', error);
        document.getElementById('loginButton').innerHTML = '<button class="login-button" disabled>Sign-In Error</button>';
      }
    };
    
    function handleCredentialResponse(response) {
      try {
        // Decode the JWT token to get user info
        const responsePayload = decodeJwtResponse(response.credential);
        
        document.getElementById('userEmail').textContent = responsePayload.email;
        document.getElementById('loginButton').style.display = 'none';
        document.getElementById('userInfo').style.display = 'block';
        
        // Store the user info in localStorage for persistence
        localStorage.setItem('userEmail', responsePayload.email);
        localStorage.setItem('userName', responsePayload.name);
        
        console.log('Successfully signed in:', responsePayload.email);
      } catch (error) {
        console.error('Error handling credential response:', error);
        alert('Error signing in. Please try again.');
      }
    }
    
    function decodeJwtResponse(token) {
      try {
        const base64Url = token.split('.')[1];
        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
        return JSON.parse(jsonPayload);
      } catch (error) {
        console.error('Error decoding JWT response:', error);
        throw new Error('Invalid token format');
      }
    }
    
    function signIn() {
      try {
        if (typeof google === 'undefined' || !google.accounts) {
          alert('Google Sign-In is not available. Please check your internet connection and try again.');
          return;
        }
        google.accounts.id.prompt((notification) => {
          if (notification.isNotDisplayed() || notification.isSkippedMoment()) {
            console.warn('Google Sign-In prompt not displayed:', notification);
            alert('Unable to show Google Sign-In. Please try refreshing the page.');
          }
        });
      } catch (error) {
        console.error('Error during sign in:', error);
        alert('Error during sign in. Please try again.');
      }
    }
    
    function signOut() {
      // Clear stored user info
      localStorage.removeItem('userEmail');
      localStorage.removeItem('userName');
      
      // Update UI
      document.getElementById('loginButton').style.display = 'block';
      document.getElementById('userInfo').style.display = 'none';
      document.getElementById('userEmail').textContent = '';
    }
    
    function checkSignInStatus() {
      const userEmail = localStorage.getItem('userEmail');
      if (userEmail) {
        document.getElementById('userEmail').textContent = userEmail;
        document.getElementById('loginButton').style.display = 'none';
        document.getElementById('userInfo').style.display = 'block';
      }
    }

    let watchId, lastPos, totalDistance = 0, startTime, isTracking = false;
    let wakeLock = null;
    let positionHistory = []; // Store recent positions for current pace calculation
    let velocityHistory = []; // Store recent velocities for Kalman filter
    let useMiles = true; // Track current unit - default to miles
    let gpsReadCount = 0; // Track number of successful GPS reads
    let lastDistanceFeet = 0; // Track distance between last two GPS reads in feet
    let kalmanFilterEnabled = true; // Debug variable to enable/disable Kalman filter
    
    // Kalman filter state
    let kalmanState = {
      x: 0, y: 0, vx: 0, vy: 0, // position and velocity
      P: [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]] // covariance matrix
    };
    let lastKalmanTime = 0;

    // Conversion constants
    const KM_TO_MILES = 0.621371;
    const MILES_TO_KM = 1.60934;

    // Haversine distance calculation (returns km)
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371; // Earth radius in km
      const toRad = deg => deg * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                Math.sin(dLon/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    // Check if a GPS reading is realistic based on speed
    function isRealisticGPSReading(newPos, lastPos, timeDiff) {
      if (!lastPos || timeDiff <= 0) return true;
      
      const distance = haversine(lastPos.lat, lastPos.lon, newPos.lat, newPos.lon);
      const speedKmh = distance / (timeDiff / 3600); // km/h
      
      // Filter out readings that suggest speeds > 50 km/h (about 31 mph)
      // This is reasonable for running/walking
      return speedKmh <= 50;
    }

    // Convert lat/lon to meters (approximate)
    function latLonToMeters(lat, lon) {
      const R = 6371000; // Earth radius in meters
      const x = R * Math.cos(lat * Math.PI / 180) * Math.sin(lon * Math.PI / 180);
      const y = R * Math.sin(lat * Math.PI / 180);
      return { x, y };
    }

    // Convert meters back to lat/lon
    function metersToLatLon(x, y) {
      const R = 6371000; // Earth radius in meters
      const lat = Math.asin(y / R) * 180 / Math.PI;
      const lon = Math.asin(x / (R * Math.cos(lat * Math.PI / 180))) * 180 / Math.PI;
      return { lat, lon };
    }

    // Kalman filter implementation for GPS smoothing
    function kalmanFilter(gpsLat, gpsLon, timestamp) {
      const dt = lastKalmanTime > 0 ? (timestamp - lastKalmanTime) / 1000 : 0.1; // seconds
      lastKalmanTime = timestamp;

      // Convert GPS position to meters
      const gpsMeters = latLonToMeters(gpsLat, gpsLon);
      
      // Initialize Kalman filter with first GPS reading
      if (kalmanState.x === 0 && kalmanState.y === 0) {
        kalmanState.x = gpsMeters.x;
        kalmanState.y = gpsMeters.y;
        kalmanState.vx = 0;
        kalmanState.vy = 0;
        return {
          lat: gpsLat,
          lon: gpsLon,
          velocity: 0,
          timestamp: timestamp
        };
      }
      
      // State transition matrix (constant velocity model)
      const F = [
        [1, 0, dt, 0],
        [0, 1, 0, dt],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
      ];

      // Process noise covariance matrix
      const q = 0.1; // Process noise parameter
      const Q = [
        [dt*dt*dt*dt/4, 0, dt*dt*dt/2, 0],
        [0, dt*dt*dt*dt/4, 0, dt*dt*dt/2],
        [dt*dt*dt/2, 0, dt*dt, 0],
        [0, dt*dt*dt/2, 0, dt*dt]
      ].map(row => row.map(val => val * q));

      // Measurement matrix (we only observe position)
      const H = [
        [1, 0, 0, 0],
        [0, 1, 0, 0]
      ];

      // Measurement noise covariance matrix
      const r = 10; // GPS noise parameter (meters)
      const R = [
        [r*r, 0],
        [0, r*r]
      ];

      // Predict step: x_pred = F * x
      const x_pred = [
        F[0][0] * kalmanState.x + F[0][1] * kalmanState.y + F[0][2] * kalmanState.vx + F[0][3] * kalmanState.vy,
        F[1][0] * kalmanState.x + F[1][1] * kalmanState.y + F[1][2] * kalmanState.vx + F[1][3] * kalmanState.vy,
        F[2][0] * kalmanState.x + F[2][1] * kalmanState.y + F[2][2] * kalmanState.vx + F[2][3] * kalmanState.vy,
        F[3][0] * kalmanState.x + F[3][1] * kalmanState.y + F[3][2] * kalmanState.vx + F[3][3] * kalmanState.vy
      ];

      // P_pred = F * P * F^T + Q
      const P_pred = [
        [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]
      ];
      
      // First calculate F * P
      const FP = [
        [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]
      ];
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          for (let k = 0; k < 4; k++) {
            FP[i][j] += F[i][k] * kalmanState.P[k][j];
          }
        }
      }
      
      // Then calculate (F * P) * F^T
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          for (let k = 0; k < 4; k++) {
            P_pred[i][j] += FP[i][k] * F[j][k];
          }
          P_pred[i][j] += Q[i][j];
        }
      }

      // Update step
      const y = [gpsMeters.x - x_pred[0], gpsMeters.y - x_pred[1]]; // Innovation
      
      // S = H * P_pred * H^T + R
      const S = [
        [0, 0], [0, 0]
      ];
      for (let i = 0; i < 2; i++) {
        for (let j = 0; j < 2; j++) {
          S[i][j] = R[i][j];
          for (let k = 0; k < 4; k++) {
            S[i][j] += H[i][k] * P_pred[k][j];
          }
        }
      }

      const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0];
      if (Math.abs(detS) < 1e-10) {
        // If determinant is too small, skip update
        return {
          lat: gpsLat,
          lon: gpsLon,
          velocity: Math.sqrt(kalmanState.vx * kalmanState.vx + kalmanState.vy * kalmanState.vy),
          timestamp: timestamp
        };
      }
      
      const S_inv = [
        [S[1][1] / detS, -S[0][1] / detS],
        [-S[1][0] / detS, S[0][0] / detS]
      ];

      // Calculate Kalman gain: K = P_pred * H^T * S^(-1)
      const K = [
        [0, 0], [0, 0], [0, 0], [0, 0]
      ];
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 2; j++) {
          for (let k = 0; k < 2; k++) {
            K[i][j] += P_pred[i][k] * H[j][k] * S_inv[j][k];
          }
        }
      }

      // Update state: x = x_pred + K * y
      kalmanState.x = x_pred[0] + K[0][0] * y[0] + K[0][1] * y[1];
      kalmanState.y = x_pred[1] + K[1][0] * y[0] + K[1][1] * y[1];
      kalmanState.vx = x_pred[2] + K[2][0] * y[0] + K[2][1] * y[1];
      kalmanState.vy = x_pred[3] + K[3][0] * y[0] + K[3][1] * y[1];

      // Update covariance: P = P_pred - K * H * P_pred
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          let sum = 0;
          for (let k = 0; k < 2; k++) {
            sum += K[i][k] * H[k][j];
          }
          kalmanState.P[i][j] = P_pred[i][j] - sum;
        }
      }

      // Convert back to lat/lon
      const filteredPos = metersToLatLon(kalmanState.x, kalmanState.y);
      
      // Calculate velocity magnitude
      const velocity = Math.sqrt(kalmanState.vx * kalmanState.vx + kalmanState.vy * kalmanState.vy);
      
      return {
        lat: filteredPos.lat,
        lon: filteredPos.lon,
        velocity: velocity,
        timestamp: timestamp
      };
    }

    // Convert distance to current unit
    function convertDistance(km) {
      return useMiles ? km * KM_TO_MILES : km;
    }

    // Convert speed to current unit
    function convertSpeed(kmPerHour) {
      return useMiles ? kmPerHour * KM_TO_MILES : kmPerHour;
    }

    // Get current unit label
    function getUnitLabel() {
      return useMiles ? 'mi' : 'km';
    }

    // Get current pace unit
    function getPaceUnit() {
      return useMiles ? '/mi' : '/km';
    }

    // Format time as HH:MM:SS
    function formatTime(seconds) {
      const hrs = Math.floor(seconds / 3600);
      const mins = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    // Format pace as MM:SS /unit
    function formatPace(speedInCurrentUnit) {
      if (speedInCurrentUnit <= 0) return '--:--';
      const minutesPerUnit = 60 / speedInCurrentUnit;
      const mins = Math.floor(minutesPerUnit);
      const secs = Math.floor((minutesPerUnit - mins) * 60);
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    // Calculate current pace based on last 30 seconds or all available data if less than 30 seconds
    function calculateCurrentPace() {
      const now = Date.now();
      const elapsed = (now - startTime) / 1000; // seconds since start
      
      // If less than 30 seconds have elapsed, use all available data
      const timeWindow = Math.min(30, elapsed);
      const timeWindowMs = timeWindow * 1000;
      const windowStart = now - timeWindowMs;
      
      // Filter positions from the time window
      const recentPositions = positionHistory.filter(pos => pos.timestamp >= windowStart);
      
      if (recentPositions.length < 2) return 0;
      
      // Calculate total distance in the time window (in km)
      let recentDistance = 0;
      for (let i = 1; i < recentPositions.length; i++) {
        const prev = recentPositions[i-1];
        const curr = recentPositions[i];
        recentDistance += haversine(prev.lat, prev.lon, curr.lat, curr.lon);
      }
      
      // Convert to speed in current unit (timeWindow seconds = timeWindow/3600 hours)
      const speedKmPerHour = recentDistance / (timeWindow / 3600);
      return convertSpeed(speedKmPerHour);
    }

    function toggleUnit() {
      useMiles = document.getElementById('unitToggle').checked;
      updateDisplay();
    }

    function toggleKalmanFilter() {
      kalmanFilterEnabled = document.getElementById('kalmanDebugToggle').checked;
      console.log('Kalman filter', kalmanFilterEnabled ? 'enabled' : 'disabled');
    }

    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release', () => {
            console.log('Wake Lock was released');
          });
          console.log('Wake Lock is active');
        }
      } catch (err) {
        console.warn('Wake Lock failed:', err);
      }
    }

    function updateDisplay() {
      if (!isTracking) return;
      
      const elapsed = (Date.now() - startTime) / 1000; // seconds
      const avgSpeedKmPerHour = totalDistance / (elapsed / 3600); // km/h
      const avgSpeedInCurrentUnit = convertSpeed(avgSpeedKmPerHour);
      const currentSpeedInCurrentUnit = calculateCurrentPace();
      
      const distanceInCurrentUnit = convertDistance(totalDistance);
      const unitLabel = getUnitLabel();
      const paceUnit = getPaceUnit();
      
      document.getElementById('distance').textContent = distanceInCurrentUnit.toFixed(2) + ' ' + unitLabel;
      document.getElementById('time').textContent = formatTime(elapsed);
      document.getElementById('pace').textContent = formatPace(avgSpeedInCurrentUnit) + ' ' + paceUnit;
      document.getElementById('currentPace').textContent = formatPace(currentSpeedInCurrentUnit) + ' ' + paceUnit;
    }

    // Common validation and setup for tracking functions
    function validateTrackingEnvironment() {
      if (!navigator.geolocation) {
        alert("Geolocation not supported by this browser.");
        return false;
      }

      // Check if we're running on HTTPS or localhost
      if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        alert("Geolocation requires HTTPS or localhost. Please run this app on a local server (e.g., python -m http.server 8000) or deploy it to HTTPS.");
        return false;
      }

      return true;
    }

    // Common GPS watching logic
    function startGPSWatching() {
      requestWakeLock();
      isTracking = true;

      // Update button states
      document.getElementById('startBtn').style.display = 'none';
      document.getElementById('pauseBtn').style.display = 'inline-block';
      document.getElementById('resumeBtn').style.display = 'none';
      document.getElementById('stopBtn').style.display = 'inline-block';

      // Start display updates
      const displayInterval = setInterval(updateDisplay, 1000);

      watchId = navigator.geolocation.watchPosition(pos => {
        const { latitude, longitude } = pos.coords;
        const timestamp = Date.now();
        
        // Increment GPS read count
        gpsReadCount++;
        
        const newPos = { lat: latitude, lon: longitude, timestamp };
        const timeDiff = lastPos ? (timestamp - lastPos.timestamp) / 1000 : 0; // seconds
        
        // Only process realistic GPS readings
        if (isRealisticGPSReading(newPos, lastPos, timeDiff)) {
          let processedPos, processedVelocity;
          
          if (kalmanFilterEnabled) {
            // Apply Kalman filter to smooth GPS data
            const filteredData = kalmanFilter(latitude, longitude, timestamp);
            processedPos = { 
              lat: filteredData.lat, 
              lon: filteredData.lon, 
              timestamp: timestamp 
            };
            processedVelocity = filteredData.velocity;
          } else {
            // Use raw GPS data without filtering
            processedPos = { 
              lat: latitude, 
              lon: longitude, 
              timestamp: timestamp 
            };
            // Calculate velocity from raw GPS data
            if (lastPos && timeDiff > 0) {
              const distance = haversine(lastPos.lat, lastPos.lon, latitude, longitude);
              processedVelocity = distance / (timeDiff / 3600); // km/h
            } else {
              processedVelocity = 0;
            }
          }
          
          // Add processed position to history
          positionHistory.push(processedPos);
          
          // Add velocity to history
          velocityHistory.push({
            velocity: processedVelocity,
            timestamp: timestamp
          });
          
          // Keep last 60 seconds of history to support rolling 30-second window calculation
          const sixtySecondsAgo = timestamp - 60000;
          positionHistory = positionHistory.filter(pos => pos.timestamp >= sixtySecondsAgo);
          velocityHistory = velocityHistory.filter(vel => vel.timestamp >= sixtySecondsAgo);
          
          if (lastPos) {
            // Use processed position for distance calculation
            const d = haversine(lastPos.lat, lastPos.lon, processedPos.lat, processedPos.lon);
            totalDistance += d;
            // Convert distance to feet (1 km = 3280.84 feet)
            lastDistanceFeet = Math.round(d * 3280.84);
          } else {
            lastDistanceFeet = 0;
          }
          lastPos = processedPos;
        }
        
        // Update debug info
        document.getElementById('debugInfo').textContent = `${gpsReadCount} GPS reads, ${lastDistanceFeet} feet`;
      }, err => {
        console.error('Geolocation error:', err);
        let errorMessage = "Error getting location: ";
        switch(err.code) {
          case err.PERMISSION_DENIED:
            errorMessage += "Location permission denied. Please allow location access in your browser settings.";
            break;
          case err.POSITION_UNAVAILABLE:
            errorMessage += "Location information unavailable. Please check your GPS/network connection.";
            break;
          case err.TIMEOUT:
            errorMessage += "Location request timed out. Please try again.";
            break;
          default:
            errorMessage += "Unknown error occurred.";
        }
        alert(errorMessage);
        stopTracking();
      }, {
        enableHighAccuracy: true,
        maximumAge: 1000,
        timeout: 10000
      });

      // Store interval ID for cleanup
      window.displayInterval = displayInterval;
    }

    function startTracking() {
      if (!validateTrackingEnvironment()) return;

      // Initialize tracking state
      startTime = Date.now();
      totalDistance = 0;
      lastPos = null;
      positionHistory = [];
      velocityHistory = [];
      gpsReadCount = 0;
      lastDistanceFeet = 0;
      
      // Initialize Kalman filter state
      kalmanState = {
        x: 0, y: 0, vx: 0, vy: 0,
        P: [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]
      };
      lastKalmanTime = 0;
      
      // Reset debug info
      document.getElementById('debugInfo').textContent = '0 GPS reads, 0 feet';

      // Start GPS watching
      startGPSWatching();
    }

    function pauseTracking() {
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      if (window.displayInterval) {
        clearInterval(window.displayInterval);
        window.displayInterval = null;
      }
      isTracking = false;
      
      // Update button states
      document.getElementById('startBtn').style.display = 'none';
      document.getElementById('pauseBtn').style.display = 'none';
      document.getElementById('resumeBtn').style.display = 'inline-block';
      document.getElementById('stopBtn').style.display = 'inline-block';
    }

    function resumeTracking() {
      if (!validateTrackingEnvironment()) return;

      // Resume GPS watching (preserves existing tracking state)
      startGPSWatching();
    }

    function stopTracking() {
      if (wakeLock) {
        wakeLock.release();
        wakeLock = null;
      }
      
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      
      if (window.displayInterval) {
        clearInterval(window.displayInterval);
        window.displayInterval = null;
      }
      
      isTracking = false;
      
      // Reset to initial state
      document.getElementById('startBtn').style.display = 'inline-block';
      document.getElementById('pauseBtn').style.display = 'none';
      document.getElementById('resumeBtn').style.display = 'none';
      document.getElementById('stopBtn').style.display = 'none';
    }

    // Register service worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js');
    }
  </script>
</body>
</html>
